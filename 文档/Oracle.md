# Oracle

始记于2023/07/13  14 : 32       今早被勒令留校学习，退了车票，交了5%滞纳金(共拾柒元伍角整)，假期计划被全盘打乱，情绪不佳，心生怨怼。

方才平缓

该笔记为阅读+实践记录

1. Oracle从入门到项目实践[聚慕课教育研发中心  著][]

2. Oracle数据库应用案例课堂[刘玉红 郭广新 著][]

3. Oracle19c从入门到精通[王英英 著][]

个人觉得第一本书更适合初学者，我也读得比较仔细；

需要一定的SQL基础，该笔记缺少很多关键部分，更多的是用来记录学习过程；

------------warm_stones

## Sqlplus基础操作

### 使用

在**命令提示符窗口**输入 :  `sqlplus system/000198`



### 退出

直接在末尾输入： `quit`



## Oracle体系结构

操作系统中只有**一个**库，可以看作Oracle只有一个大数据库

**实例**：一个Oracle实例有一系列的后台进程和内存结构组成。一个数据库可以有n个实例。

**数据文件**：数据库的物理存储单位。dbf

**表空间**：Oracle队伍里数据库上相关数据文件(ORA 或 DBF 文件)的逻辑映射。   

### 逻辑存储结构

表空间：最大的逻辑划分区域       和数据文件相对应

数据段：独立的逻辑存储结构

数据区：Oracle存储分配的最小单位

数据块：Oracle逻辑存储结构中最小的逻辑单位

***一个数据段由一个或多个数据区组成       一个数据区由一个或多个数据块组成***



### 物理存储结构

#### 基础文件

数据文件：物理上存放着数据库的对象（表和索引）一个数据库可以由多个数据文件组成

控制文件

日志文件



#### 外部文件

参数文件

密码文件

警报文件

跟踪文件

备份文件



### 内存结构与组成

#### 结构

##### 系统全局区SGA

进程共享部分

存储了Oracle数据库实例的数据和控制文件信息，和Oracle的进程组成了Oracle的实例

##### 程序全局区PGA

内存区

包含每个服务器进程的数据及控制信息

包含：专用SQL区，会话内存，SQL工作区



#### 组成

##### 数据库高速缓冲区

##### 数据字典缓冲区

##### 重做日志缓冲区

##### SQL共享池



### 数据库进程与实例

#### 进程

##### 用户进程

##### 服务器进程

##### 后台进程



#### 实例

Oracle数据库实例是用户向数据库读/写数据的媒介，是一种访问数据库的机制

数据库实例由内存结构和一些后台进程组成，它的内存结构也称为系统全局区



### 数据字典

略





## 重点知识

### 一、前置准备

```sql
-------------------------------------------------------------------------------
--查看本地账户权限
SELECT * FROM SESSION_PRIVS;

--创建表空间
DEFAULT TABLESPACE waterboss
datafile 'C:\Oracle\waterboss.dba'  --文件地址
size 100m                           --空间大小100m
autoextend ON                       --存满了则会 自动扩充
NEXT 10m;                           --每次10m

--创建用户
CREATE USER wateru002992213211ser   --创建user用户
identified BY itcast    --设置密码
DEFAULT TABLESPACE waterboss;

--用户赋权
GRANT dba TO wateruser;

----
SELECT * FROM v$database;
SELECT * FROM v$parameter where name = 'db_domain';
-------------------------------------------------------------------------------
```

### 二、对数据表的基础操作

####  创建表/约束

```sql
-------------------------------------------------------------------------------
--创建表
CREATE TABLE tb_emp1
(
    id       NUMBER(11),
    name     VARCHAR2(25),
    deptId   NUMBER(11),
    salary   NUMBER(9,2)
);
------------------------------------------
--主键约束
--直接使用主键约束
CREATE TABLE tb_emp2
(
    id      NUMBER(11) PRIMARY KEY,
    name    VARCHAR2(25),
    deptId  NUMBER(11),
    salary  NUMBER(9,2)
);
--定义完所有列之后 指定主键
CREATE TABLE tb_emp3
(
    id      NUMBER(11),
    name    VARCHAR2(25),
    deptId  NUMBER(11),
    salary  NUMBER(9,2),
    PRIMARY KEY(id)          --括号内字段设为主键
);
--多字段联合主键
CREATE TABLE tb_emp4
(
    name    VARCHAR2(25),
    deptId  NUMBER(11),
    salary  NUMBER(9,2),
    PRIMARY KEY(name,deptId)  --括号内多个字段
);
--使用ALTER TABLE
--添加主键
ALTER TABLE tb_emp1
ADD CONSTRAINT pk_id PRIMARY KEY(id); --pk_id为约束名称
--移除主键
ALTER TABLE tb_emp1
DROP CONSTRAINT pk_id;

--
--使用外键约束
CREATE TABLE tb_dept1
(
    id       NUMBER(11)      PRIMARY KEY,
    name     VARCHAR2(22)    NOT NULL,
    location VARCHAR2(50)
);
CREATE TABLE tb_emp5
(
    id      NUMBER(11) PRIMARY KEY,
    name    VARCHAR2(25),
    deptId  NUMBER(11),
    salary  NUMBER(9,2),
    CONSTRAINT fk_emp_dept1 FOREIGN KEY (deptId) REFERENCES tb_dept1(id) --创建外键 tb_emp5(deptId) <-> tb_dept(id)
);
--在修改数据表时添加外键约束
ALTER TABLE tb_emp5
ADD CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptId)
REFERENCES tb_dept1(id)
ON DELETE CASCADE;
--移除外键约束
ALTER TABLE tb_emp5
DROP CONSTRAINT fk_emp_dept1;
-------------------------------------------------------------------------------
```



#### 其它约束

```sql
-------------------------------------------------------------------------------
--使用非空约束
--定义
--    <字段名> <数据类型> NOT NULL
--修改
--    ALTER TABLE <数据表名称>
--    MODIFY <字段名称> NOT NULL;
--移除
--    ALTER TABLE <数据表名称>
--    MODIFY <字段名称> NULL;

--唯一性约束 UNIQUE
--除了最终定义唯一性约束，其余规则与主键约束相同

--默认约束
-- <字段名> <数据类型> DEFAULT <默认值>

--检查约束
-- CONSTRAINT <检查约束的名称> CHECK(检查条件)

--设置数据类型自动增加
--自增值的初始值为1，每新增一条记录，字段自动加1
-- 字段名 数据类型 GENERATED BY DEFAULT AS IDENTITY
-------------------------------------------------------------------------------
```



#### 查看表结构

```sql
-------------------------------------------------------------------------------
--查看数据表结构
DESCRIBE tb_emp1;
DESC tb_emp1;
-------------------------------------------------------------------------------
```



#### 修改数据表

```sql
-------------------------------------------------------------------------------
--修改数据表
--
--修改表名
--ALTER TABLE <旧表名> RENAME TO <新表名>;
ALTER TABLE tb_emp5 RENAME TO new_tb_emp5;
SELECT * FROM tb_emp5;  -- error : 表或视图 tb_emp5不存在
--
--修改字段名
--ALTER TABLE <表名> RENAME COLUMN <旧字段名> TO <新字段名>;
ALTER TABLE tb_dept2 RENAME COLUMN id TO new_id;
SELECT * FROM tb_dept2;

--
--修改字段的数据类型
--ALTER TABLE <表名> MODIFY <字段名> <数据类型>;
CREATE TABLE tb_dept2
(
    id       NUMBER(11),
    name     VARCHAR2(22),
    location VARCHAR2(50)
);
ALTER TABLE tb_dept2 MODIFY name VARCHAR2(30);

--
--添加字段
--添加无完整性约束条件的字段
ALTER TABLE tb_dept2 ADD manegerId NUMBER(10);
--添加有完整性约束条件的字段
ALTER TABLE tb_dept2 ADD column1 NUMBER(10) NOT NULL;

--
--删除字段
--ALTER TABLE <表名> DROP COLUMN <字段名>
--在删除字段时，常常在字段后添加CASCADE CIBSTRAINTS 目的是将与该字段相关的约束一并删去

------------------------------------------
--删除数据表
--直接删除没有被关联的数据表
--DROP TABLE <表名>

--删除被关联的数据表
--需要先移除 关联（外键约束），然后再删除
-------------------------------------------------------------------------------
```



### 三、数据类型和运算符

#### 数据类型

##### 数值类型

```sql
-- NUMBER(m,n)  可变长数值列，m为所有有效数字的位数，n是小数点以后的位数
-- 精度为30位      m:1 ~ 38        n:-84 ~ 127
```

##### 日期与时间类型

```sql
-- DATE记录日期
-- TIMESTAMP记录日期和时间（特别是需要显示上下午或者时区的情况）
```

##### 字符串类型

```sql
-- CHAR    固定长度（会自动补齐尾插空格）
-- VARCHAR 可变长度
-- CHAR更快，但可能浪费ko
```



#### 运算符

##### 逻辑运算

```sql
与   AND  &&
或   OR   || 
非   NOT
异或 XOR 
```

##### 位运算

```sql
与   &
或   |
非   ~
异或 ^
左移 <<
右移 >>
```

##### 比较运算

```sql
安全的等于          <=>
不等于              <>(!=)
判断是否为NULL      IS NULL
判断是否不为NULL     IS NOT NULL
判断是否落在两值之间  BETWEEN ... AND ...
IN
NOT IN
通配符匹配           LIKE
```



### 四、Oracle的函数

#### 数学函数

```sql
-- 绝对值函数
ABS(x)
-- 算术平方根函数
SQRT(x)
-- 求余函数
MOD(x,y) --求x被y除后的余数
-- 取整函数
CEIL(x)  --向上取整
FLOOR(x) --向下取整

-- 获取随机数的函数
DBMS_RANDOM.RANDOM      --返回一个随机值
DBMS_RANDOM.RANDOM(x,y) --返回一个x~y的随机值

-- 舍入函数
ROUND(x)
ROUND(x,y)
TRUNC(x,y)

-- 符号函数
-- x:负、零、正 --> SIGN(x): -1、0、1
SIGN(x)

-- 幂运算函数
POWER(x,y)
EXP(x)

-- 对数运算函数
LOG(x,y)
LN(x)

-- x为弧度值
-- 正弦函数与反正弦函数
SIN(x)
ASIN(x)
-- 余弦函数与反余弦函数
COS(x)
ACOS(x)
-- 正切函数与反正切函数
TAN(x)
ATAN(x)
```

```sql
SQL> SELECT DBMS_RANDOM.VALUE(1,10),DBMS_RANDOM.VALUE(1,10) FROM dual;

DBMS_RANDOM.VALUE(1,10) DBMS_RANDOM.VALUE(1,10)
----------------------- -----------------------
             6.19531093              7.62004018

SQL> SELECT SIN(2),COS(1),TAN(0.3),TAN(1.3) FROM dual;

    SIN(2)     COS(1)   TAN(0.3)   TAN(1.3)
---------- ---------- ---------- ----------
.909297427 .540302306  .30933625 3.60210245
```



#### 字符串函数

```sql
-- 计算字符串长度的函数
LENGTH(str)

-- 合并字符串函数
CONCAT(s1,s2)

-- 字符串搜索函数
INSTR(s,x) -- 返回x字符在字符串s中的位置

-- 字母大小写转换函数
LOWER(str)
UPPER(str)

-- 截取指定长度的字符串的函数
SUBSTR(s,m,n) -- 从字符串s中截取位置m开始，指定长度n的子字符串

-- 替换字符串的函数
REPLACE(s1,s2,s3) -- s1为目标字符串，s2为要搜索的被替换字符串，s3为可选参数用于替换s2；如果不用s3参数则相当于直接删除s1中的s2

-- 删除字符串
TRIM()
LTRIM(s,n)
RTRIM(s,n)
```



#### 日期和时间函数

```sql
-- 获取当前日期和时间的函数
SYSDATE
SYSTIMESTAMP

-- 获取时区的函数
DBTIMEZONE

-- 获取指定月份最后一天的函数
LAST_DAY(date)

-- 获取指定日期后一周的日期函数
NEXT_DAY(date,char) -- char'星期X'

-- 获取指定日期特定部分的函数
EXTRACT(datetime)
```



#### 转换函数

```sql
-- 字符串转ASCII编码组成的字符串函数
ASCIISTR(char)

-- 二进制转十进制函数
-- BIN_TO_NUM(1,1,0) --> 6
BIN_TO_NUM()

-- 数据类型转换函数
CAST(expr AS type_name) -- expr:数据实例     type_name:数据类型名

-- 数值转换为字符串函数
TO_CHAR(n[,fmt[,nlsparam]])

--     char: 需要转换的字符串
--      fmt: 要转换成字符的格式
-- nlsparam: 控制格式化时使用的语言类型
-- 字符转日期函数
TO_DATE(char[,fmt[,nlsparam]])

--     expr: 需要转换的字符串
--      fmt: 要转换成数字的格式
-- nlsparam: 指定fmt的特征，包括小数点字符、组分隔符和本地货币符号
-- 字符串转数字函数
TO_NUMBER(expr[,fmt[,nlsparam]])
```



#### 系统信息函数

```sql
-- 返回登录名函数
USER
-- 返回会话以及上下文信息函数
USERENV(parameter)
-- parameter:LANGUAGE,SESSION,ISDBA
```



#### 应用实例

- [ ] 在这里发现使用 **"   "** 会报错，只能使用**'   '**

```sql
SQL> CREATE TABLE member
  2  (
  3  m_id NUMBER(11) GENERATED BY DEFAULT AS IDENTITY,
  4  m_FN VARCHAR2(100),
  5  m_LN VARCHAR2(100),
  6  m_birth DATE,
  7  m_info VARCHAR2(255) NULL
  8  );

表已创建。

SQL> -- 插入一条记录
SQL> INSERT INTO member VALUES(1011,'Halen','Park','29-6月-1907','GoodMan');

已创建 1 行。

SQL> -- 使用SELECT语句查看插入结果
SQL> SELECT * FROM member;

      M_ID
----------
M_FN
--------------------------------------------------------------------------------
M_LN
--------------------------------------------------------------------------------
M_BIRTH
--------------
M_INFO
--------------------------------------------------------------------------------
      1011
Halen
Park

      M_ID
----------
M_FN
--------------------------------------------------------------------------------
M_LN
--------------------------------------------------------------------------------
M_BIRTH
--------------
M_INFO
--------------------------------------------------------------------------------
29-6月 -07
GoodMan

```



### 五、查询数据

#### 基本查询语句

```sql
SELECT [DISTINCT]
	{* | <字段列表>}
    [
        FROM <表1>,<表2>...
        [WHERE <表达式>]
        [GROUP BY <...>]
        [HAVING <...>]
        [ORDER BY 字段 <ASC/DESC>]   -- 根据 字段 升序/降序排列
        [LIMIT <...>]
    ]

SELECT [字段1,字段2,...,字段n]
FROM [数据表或视图]
WHERE [查询条件];
```



#### 单表查询

##### WHERE

###### IN

```sql
-- 查询a_num为1或-1.1的记录
SELECT a, b, a_num, b_num
FROM alphabet
WHERE a_num IN (1,-1.1);

-- NOT IN 可以检查相反情况
```

###### BETWEEN  AND

```sql
-- 查询a_num在0和1之间的记录
SELECT a, b, a_num, b_num
FROM alphabet
WHERE a_num BETWEEN 0 and 1;
-- 查询b_num不在0和1之间的记录
SELECT a, b, a_num, b_num
FROM alphabet
WHERE b_num NOT BETWEEN 0 and 1;
```

###### LIKE

```sql
-- % 匹配任意长度的字符，包括零字符
-- _ 一次只能匹配一个字符
```

###### IS NULL

###### IS NOT NULL



##### 分组查询

```sql
GROUP BY 字段名  -- 创建分组
HAVING 条件      -- 筛选分组
```



##### ROWNUM限制查询结果

```sql
SELECT * FROM alphabet
WHERE ROWNUM < 5       -- 限制仅返回查询到的前4行（ROWNUM <= 4）
```



#### 集合函数查询

```sql
AVG()    -- 返回 某列（也可以说某字段） 的平均值

COUNT()  -- 返回 某列（也可以说某字段） 的行数
COUNT(*)  -- 返回总行数，不忽略空值
COUNT(字段)-- 返回有数值的行数

MAX()    -- 返回 某列（也可以说某字段） 的最大值

MIN()    -- 返回 某列（也可以说某字段） 的最小值

SUM()    -- 返回 某列（也可以说某字段） 值的和
```



#### 连接查询

##### 内连接

```sql
-- 只有满足条件的行会被保留
SELECT customers.id, orders.num
FROM customers INSERT JOIN orders
ON customers.id = orders.id
```



##### 外连接

```Sql
-- 左连接
-- 如果左表的某行在右表没有匹配行，则在相关联的行中，右表部分为空
-- 也就是在左表基础上进行连接
SELECT customers.id, orders.num
FROM customers LEFT OUTER JOIN orders
ON customers.id = orders.id

-- 右连接
-- 如果右表的某行在左表没有匹配行，则在相关联的行中，左表部分为空
-- 也就是在右表基础上进行连接
SELECT customers.id, orders.num
FROM customers RIGHT OUTER JOIN orders
ON customers.id = orders.id
```





#### 子查询

##### ANY/SOME

```sql
-- ANY和SOME,二者为同义词,表示满足其中任一条件
SELECT num1
FROM tal1
WHERE num1 > ANY(SELECT num2 FROM tbl2) -- 表示num1大于tbl2中任意一个num2即可
```



##### ALL

```sql
-- ALL要求要满足内层所有条件
SELECT num1
FROM tal1
WHERE num1 > ALL(SELECT num2 FROM tbl2) -- num1大于tbl2中所有num2才满足条件
```



##### EXISTS

```sql
-- EXISTS后边跟着的参数是一个子查询，该子查询至少返回一行 则EXISTS结果为TRUE
SELECT *
FROM tal1
WHERE EXISTS(SELECT num1 FROM tbl1) -- tbl1中有含非空num1值的行
```



##### IN

```sql
-- IN要求存在...
SELECT num1
FROM tal1
WHERE num1 IN (SELECT num1 FROM tbl1)  
```

##### 比较运算符

略



#### 合并查询结果

```sql
-- 直接用UNION关键字即可
-- UNION     : 执行时会删除重复记录
-- UNION ALL : 执行时会保留重复记录
SELECT column1,column2,... FROM table1
UNION [ALL]
SELECT column1,column2,... FROM table2
```



#### 为数据表和字段取别名

```sql
-- 为数据表取别名
表名 表别名
-- 为数据段取别名
字段名 AS 列别名
```



#### 正则表达式查询

**REGEXP_LIKE()**

```sql
-- 在Oracle中使用 REGEXP_LIKE()函数指定正则表达式的字符匹配模式
SELECT * 
FROM fruit_s
WHERE REGEXP_LIKE(f_name, '^b'); -- 查询f_name字段以字母'b'开头的记录

WHERE REGEXP_LIKE(f_name, 'b$'); -- 查询f_name字段以字母'b'结尾的记录

WHERE REGEXP_LIKE(f_name, 'bb'); -- 查询f_name字段值包含字符串'bb'的记录

WHERE REGEXP_LIKE(f_name, '[abc]');  -- 查询f_name字段中  包含'a','b'或'c'的记录
WHERE REGEXP_LIKE(f_name, '[^abc]'); -- 查询f_name字段中 不包含'a','b'和'c'的记录
... ...
```





### 六、插入.更新.删除数据

#### 插入数据

```sql
INSERT INTO table_name (colunm_list) VALUES (value_list)
-------------------------------------------------------------------
-- 案例
-- 往数据表中所有字段插入数据
INSERT INTO fruit_s  VALUES ('apple', 'AnHui', 'red', 3);

-- 往数据表中指定字段插入数据
INSERT INTO fruit_s (name, color, price) VALUES ('apple', 'red', 3);

-- 同时插入多条(借助SELECT ... FROM dual)
INSERT INTO fruit_s (name, color, price)
SELECT 'apple', 'red', 3   FROM dual
UNION all
SELECT 'banana','yellow',5 FROM dual;
UNION all
... ...
... ...


-- 将查询结果插入到数据表中
-- 模板
INSERT INTO table_name1 (columb_list1)
SELECT (column_list2) FROM table_name2 WHERE (condition);
-- 案例
INSERT INTO fruit_s (name, color, price)
SELECT named,colored,priced  FROM fruit_d WHERE colored = 'red';
```



#### 更新数据

```sql
UPDATE table_name
SET column_name1 = value1,column_name2 = value2,...,column_namen = valuen
WHERE (condition)
-- 需要更新的字段名 column_name1 ~ column_namen
-- 对应的更新值        value1   ~     valuen
---------------------------------------------------------------------------
```



#### 删除数据

```sql
-- 删除符合条件condition的数据记录
DELETE FROM table_name
[WHERE <condition>]
----------------------------------------------------
DELETE FROM fruit_s
WHERE color='yellow'  -- 删除所有水果颜色为yellow的数据记录

DELETE FROM fruit_S   -- 删除fruit_s表中的所有记录
-- 删除表中所有记录还可以使用TRUNCATE TABLE table_name ,直接删除表。
```





### 七、视图

#### 视图概述

视图是基于一个或多个基本表（或其他视图）的查询结果定义的，它**不存储实际的数据**，而是提供一种逻辑上的数据展示方式。

在视图中，用户可以使用SELECT、INSERT、UPDATE等语句修改记录

***对通过视图看到的数据进行修改时**，**相应的基表的数据也要发生变化**。*

***基表的数据的变化也会反映到视图中去**。*



**优点**：

- 简单化
- 安全性
- 逻辑数据独立性



```sql
CREATE TABLE t
(
    one   NUMBER(10),
    two   NUMBER(5),
    three NUMBER(1)
);
INSERT INTO t VALUES (99,88,1);
INSERT INTO t VALUES (0,0,0);
```



#### 创建视图

```sql
CREATE [OR REPLACE] [[NO] FORECE] VIEW
[schema.]view( conlumnlist )
AS subquery(子查询)
[
    WITH {READ ONLY CHECK OPTION [CONSTRAINT constraint(约束)]}
]
-- REPLACE表示替换已经创建的视图
-- [NO]FORCE表示是否强制创建视图
-- [schema.]view中chema表示视图所属方案，view表示视图本身的名称
-- WITH READ ONLY表示视图为只读
-- WITH CHECK OPTION表示一旦使用该限制，当对视图增加或修改数据时必须满足子查询的条件
```

```sql
CREATE VIEW view_t
AS
    SELECT * FROM t;
UPDATE view_t
SET three=1;
```



#### 查看视图

```sql
DESCRIBE 视图名;
```



#### 修改视图

```sql
-- CREATE OR REPLACE VIEW语句修改视图

-- ALTER语句修改视图的约束
ALTER VIEW 视图名
ADD CONSTRAINT 约束命名 约束(字段名);
```



#### 更新视图

```sql
UPDATE 视图名
SET 更改操作;
-----------------------
UPDATE view_t
SET id=newid;

DELETE FROM 视图名
WHERE (condition)
-----------------------
DELETE FROM view_t
WHERE id=wrong;
```



#### 删除视图

```sql
-- 删除视图
DROP VIEW view_t;
```



#### 限制视图的数据操作

```sql
CREATE OR REPLACE VIEW view_t
AS
    SELECT * FROM t
WITH READ ONLY ;-- 设置"只读"属性 --无法对视图进行更新了
```



### 八、PL/SQL编程

​	如果不使用PL/SQL语言，Oracle一次只能处理一条SQL语句。每条SQL语句的处理都需要客户端向服务器端执行调用操作，从而在性能上造成很大的开销。

​	使用PL/SQL语言，一个块中的所有SQL语句作为一个组，只需要客户端向服务器进行一次调用，从而减少了网络转输。

​	PL/SQL：过程化SQL语言。

#### 结构

```sql
DECLARE
声明部分;
BEGIN
执行部分;
EXCEPTION
异常处理部分;
END;
	/
```

```sql
/*
多行注释
*/
```



#### 常量和变量

##### 常量

```sql
constant_name CONSTANT datatype
[NOT NULL]
{:=| DEFAULT} expression;
```

##### 变量

```sql
variable_name datatype
[
    [NOT NULL]
{:=| DEFAULT} expression;
];
------------------------------------------
v_date    DATE:=SYSYDATE
```



#### 控制结构和语句

##### IF条件控制语句

```sql
-- 如果符合条件condition，则执行statements，否则跳过
IF condition THEN
	statements;
END IF;
--------------------------
IF condition THEN
	statements;
ELSE
	statements;
END IF;
--------------------------
IF conditionq THEN
	statements1;
ELSEIF condition2 THEN
	statements2;
[ELSEIF]
... ...
[ELSE]
END IF;
```



##### CASE条件控制语句

```sql
CASE case_operand
WHEN when_operand1 THEN
statement1;
[
WHEN when_operand2 THEN
statement2;
]
[...]...
[
ELSE 
statement;
[statement;]...;
]
END CASE;
-----------------------------------------------------
-----------------------------------------------------
CASE
WHEN boolean_expression1 THEN statement1;
[
	 boolean_expression2 THEN statement2;
]
[...]...;
[
ELSE 
statement;
[statement;]...;
]
END CASE;
```



##### LOOP循环控制语句

```sql
LOOP
	statement...
END LOOP;
--------------------------
-- 案例
<<bbscip_loop>>
LOOP
DBMS_OUTPUT.PUT_LIKE('这是一个不断让v_sum加1的循环，直到v_sum大于100结束');
v_sum:=v_sum+1;
IF v_sum>100 THEN
	DBMS_OUTPUT.PUT_LIKE('退出LOOP循环，当前v_sum为:'|| v_sum);
	EXIT bbscip_loop;
END IF;
END LOOP;
END;
	/
```



#### 异常

```sql
EXCEPTION
	WHEN e_name11 [OR e_name12 ...] THEN -- 如果是对应的异常名,则就地处理，执行statements
		statements;
	WHEN e_name21 [OR e_name22 ...] THEN
		statements;
		...
	WHEN OTHERS THEN
		statements;                      -- 如果与前面的异常都不匹配，则执行
END;
	/
```



#### 函数

```sql
CREATE [OR REPLACE] FUNCTION function_name
(变量常量声明)
RETURN 数据类型
IS | AS
BEGIN
	statement...;
END [function——name]
```



### 九、存储过程

​	存储过程是指在Oracle数据库中，一组为了完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后，再次调用时不需要再次编译，用户通过指定存储过程的名字并给出参数来执行它。

优点：

1. 减少网络通信量。
2. 执行速度更快。
3. 更强的适应性。
4. 分布式工作。

#### 创建存储过程

```sql
CREATE PROCEDURE procedure_name
AS 
BEGIN
	dbms_output.put_line('您好，这是个简单的存储过程');
END;
```



#### 调用存储过程

```sql
execute procedure_name;  -- 直接调用存储过程
exec procedure_name;     -- 缩写
```

```
BEGIN
	procedure_name;
END;
```



#### 查看存储过程

```sql
SELECT * 
FROM USER_SOURCE
WHERE NAME='goal name'
ORDER BY LIKE;
```



#### 存储过程的参数





#### 修改存储过程

```sql
CREATE OR REPLACE PROCEDURE table_s,
AS
	......
BEGIN
	......
END;
```



#### 删除存储过程

```
DROP PROCEDURE [schema.]procedure_name
//删除存储所属的机构
```



#### 查看存储过程的错误

```sql
SHOW ERRORS PROCEDURE procedure_name;
```



### 十、Oracle触发器

触发器是一个特殊的存储过程，不同的是：执行存储过程要使用EXEC语句来调用，触发器的执行不需要EXEC语句来调用，也不需要手动启动。

当一个预定义事件发生时，触发器就会被Oracle自动调用。

#### 创建触发器

```sql
CREATE [OR REPLACE] TRIGGER 触发器名 
触发时间 触发事件
ON 表名
[FOR EACH ROW]
BEGIN
	PL/SQL语句
END;
----------------------------------------------------------------------------------
-- 触发时间:指明触发器何时执行                 BEFORE  AFTER
-- 触发事件:知名哪些数据库操作会触发此触发器     INSERT  UPDATE  DELETE
-- 表名:数据库触发器所在的数据表
-- FOR EACH ROW:对数据表的每一行执行一次触发器。没有这一段语句的话，就只对整个数据表执行一次
----------------------------------------------------------------------------------
-- 创建一个触发器num_sum,在“插入persons表的num字段”后,“更新sales表的sum字段”
CREATE TRIGGER num_sum
AFTER INSERT
ON persons
FOR EACH ROW
BEGIN
	INSERT INTO sales VALUES(NEW.name,7*NEW.num);
END;
```



#### 查看触发器

##### 查看触发器的名称

```sql
SELECT OBJECT_NAME 
FROM USER_OBJECTS 
WHERE OBJECT_TYPE='TRIGGER';
```

##### 查看触发器的内容信息

```sql
-- 根据触发器名称查看
SELECT * 
FROM USER_SOURCE
WHERE NAME='触发器名称'
ORDER BY LINE;
```



#### 修改触发器

```sql
CREATE OR REPLACE TRIGGER 触发器名称
... ...
```



#### 删除触发器

```sql
DROP TRIGGER [schema.]trigger_nam
```



### 十一、游标

#### 认识游标

​	**游标**是Oracle的一种数据访问机制，它允许用户访问单独的数据行，用户可以对每一行进行单独处理，从而降低系统开销和潜在的阻隔情况，用户也可以使用这些数据生成SQL代码并立即执行输出。

​	**游标**类似于一个可以变动的光标。类似于C中的指针，**游标**可以指向结果集中的任意位置。

​	默认情况下，**游标**可以返回当前行的数据记录，且只能返回一行的记录。如果想要返回多行的记录，就需要不断地滚动游标，把需要的数据记录查询一遍。用户可以操作游标所在行的记录，例如把返回记录作为另一个查询的条件等。



#### 显式游标

使用前必须有明确的游标声明和定义，这样的游标定义会关联数据查询语句，通常会返回一行或多行的数据记录。

显示游标需要用户自己编写代码，一切由用户控制。

##### 显示游标的语法

```sql
CURSOR cursor_name
	[(parameter_name  datatype, ... )]
	IS select_statement;
-- cursor_name是游标的名称
-- parameter_name表示参数名称 ,datatype表示参数类型
-- select_statement是游标关联的SELECT语句 SELECT * FROM tbl WHERE ... GROUP ... ...
---------------------------------------------------------------
-- 案例：声明一个游标cursor_fruits——作用是使用SELECT语句从fruits表中查询出fruit_name的字段
DECLARE
CURSOR cursor_fruits
IS SELECT fruit_name FROM fruits;
```

##### 打开游标

```sql
OPEN cursor_name;
-----------------------
OPEN cursor_fruits  --打开先前声明的游标
```

##### 读取游标中的数据

```sql
-- 将从游标cursor_name中读取的数据放入到Record_name中
FETCH cursor_name INTO Record_name;
-- 如果要读取多个记录，要和循环语句一起使用
LOOP
	FETCH frt_cur INTO cur_fruits;-- 表示利用FETCH语句从结果集中提取游标指向的当前行的记录
	EXIT WHEN frt_cur%NOTFOUND;-- 表示利用游标的属性在没有数据记录时去退出循环
	dbms_output.put_line(cur_fruits.f_id||'.'||cur_fruits.f_name);-- 输出
END LOOP;
```

##### 关闭游标

```sql
CLOSE cursor_name
-- 释放游标cursor_name占用的服务器资源
```



##### 显示游标的属性

```sql
%ISOPEN     -- 判断游标属性是否打开，OPEN则返回true，否则返回false
%FOUND      -- 检查行数据是否有效，有效true，无效false
%NOTFOUNT   -- 同%FOUND相反
%ROWCOUNT   -- 表示累积到当前位置，使用FETCH提取数据的行数
```



##### 案例

```sql
set serveroutout on;-- 打开Oracle自带的输出方法dbms_output
DECLARE
 CURSOR frt_cur -- 声明一个名为frt_cur的游标
 IS SELECT  f_id,f_name  FROM fruit;-- 表示游标关联的查询
cur_fruits  frt_cur%ROWTYPE;-- 定义一个游标变量，名为frt_cur

BEGIN
	OPEN frt_cur;-- 打开游标
	FETCH frt_cur INTO cur_fruits;-- 表示利用FETCH语句从结果集中提取游标指向的当前行的记录
	dbms_output.put_line(cur_fruits.f_id||'.'||cur_fruits.f_name);-- 输出
	CLOSE frt_cur;-- 关闭游标
END;
```







#### 隐式游标

和显式游标不同，隐式游标由数据库自动管理，用户无法控制此游标，但能得到它的属性。

隐式游标的默认名称为SQL，也叫SQL游标。

##### 隐式游标的属性

```sql
%ISOPEN     -- Oracle自行控制该属性，总是返回false
%FOUND      -- 反映了操作是否影响数据，影响true，不影响false
%NOTFOUNT   -- 同%FOUND相反
%ROWCOUNT   -- 反映了操作对数据的
```



##### 案例

```sql
set serveroutout on;-- 打开Oracle自带的输出方法dbms_output
DECLARE
 cur_id fruits.f_id%TYPE;
 cur_name fruits.f_name%TYPE;
 cur_price fruits.f_price%TYPE;
BEGIN
	SELECT f_id,f_name,f_price INTO cur_id,cur_name,cur_price
	FROM fruits
	WHERE f_price=5.3;
	IF SQL%FOUND THEN
		dbms_output.put_line(cur_id||'.'||cur_name||'.'||cur_price);
	END IF;
END;
```





**在游标中可以使用异常处理**



### 十二、管理表空间

#### 初识表空间

​	表空间是数据库的**逻辑划分**，Oracle数据库被划分为多个表空间的逻辑区域，形成Oracle数据库的**逻辑结构**。

​	表空间是Oracle数据库恢复的最小单位，容纳许多数据库实体，如数据表、视图、索引、聚簇 ... ...

​	一个表空间只能属于一个数据库，一个数据库可以有多个表空间，而一个表空间则对应着一个或多个物理的数据库文件。（**STSTEM表空间**）

​	表空间的功能：

1. 决定数据库实体的空间分配
2. 设置数据库用户的空间份额
3. 控制数据库部分数据的可用性
4. 分布数据于不同的设备之间—>改善性能
5. 备份和恢复数据

​	用户操纵Oracle数据库中的数据时，在**表空间**中所需要的权力：

1. 被授予一个或多个表空间的RESOURCE特权
2. 被指定了默认的表空间
3. 被分配了指定表空间中存储空间的使用份额
4. ... ...



#### 查看表空间

```sql
-- 查询当前登录用户默认的表空间名称
SELECT TABLESPACE_NAME FROM DBA_TABLESPACES;

-- 查询SYSTEM默认表空间的使用情况
SELECT * FROM DBA_FREE_SPACE WHERE TABLESPACE_NAME='SYSTEM';
```



#### 管理表空间

##### 创建表空间

```sql
CREATE TABLESPACE tablespace_name
DATAFILE filename SINE size    -- 指定在表空间中存放的数据文件的文件名和数据库文件的大小
[AUTOEXTENO [ON/OFF]]NEXT size -- 指定文件扩展方式;ON:自动扩展,OFF:非自动扩展;NEXT:扩展一次的大小
[MAXSIZE size]                 -- 指定自动扩展的最大值
[PERMANENT|TEMPORARY]          -- 指定表空间类型  永久|临时 ; 默认为永久性表空间
[EXTENT MANAGEMENT             -- 指定表空间的管理方式: 
[DICTIONARY|LOCAL              -- （默认为本地管理方式）DICTIONARY:字典管理  LOCAL:本地管理
[AUTOALLOCATE|UNIFORM.[SIZE integer[K|M]]]]]

```



##### 设置表空间的可用状态

```sql
ALTER TABLESPACE tablespace_name{ONLINE|OFFLINE[NORMAL|TEMPORARY|IMM]}
```



##### 设置表空间的读写状态

```sql
ALTER TABLESPACE tablespace_name READ{ONLY|WRITE}
```



##### 重命名表空间

```sql
ALTER TABLESPACE ... RENAME TO ...
```

##### 删除表空间

```sql
DROP TABLESPACE tablespace_name
```



#### 管理临时表空间

```sql
-- 创建
CREATE TEMPORART TABLESPACE tablespace_name
TEMPFILE filename SINE size;
-- 查看
SELECT TABLESPACE_NAME FROM DBA_TEMP_FILES;
-- 删除
DROP TABLESPACE tablespace_name INCLUDING CONTENTS AND DATAFILES
```



#### 管理数据文件

##### 移动数据文件

步骤如下：

(1)把要存放的文件的表空间设置为脱机状态

```sql
ALTER TABLESPACE 表空间 OFFLINE;
```

(2)可以手动吧要移动的文件移动到其它的表空间中
(3)更改数据文件的名称

```sql
ALTER TABLESPACE 表空间名称 RENAME oldfilename TO newfilename;
```

(4)把该表空间设置为联机状态

```sql
ALTER TABLESPACE 表空间名称 ONLINE;
```



##### 删除数据文件

数据文件处在以下三种情况时，不能被删除：

1. 数据文件或数据文件所在的表空间处于只读状态
2. 数据文件中存在数据
3. 数据文件是表空间中唯一一个或第一个数据文件



### 十三、事务与锁









### 十四、Oracle的安全管理







### 十五、控制文件、日志







### 十六、数据备份、还原









### 十七、Oracle性能优化

#### 优化简介



#### 优化查询



#### 优化数据库结构



#### 优化Oracle服务器







### 十八、Java操作Oracle数据库

#### JDBC概述





#### java连接数据库





#### Java操作Oracle数据库





