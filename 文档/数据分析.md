# IPython基础

## **tab补全**

补全对象或模块属性

补全时输入下划线找到私有方法

补全文件地址

补全函数中的关键字参数

... ... ...

## 内省

### ?

```python
# 显示一些关于该对象的概要信息
# 显示文档字符串
```



### ??

```python
# 显示函数的源代码
```



### %run

```python
# 将文件名作为参数传给%run命令   全局生效
%run ipython_script_test.py
# %load 将脚本导入一个代码单元   局部生效
```



### Ctrl-C

中断运行中的代码



### %paste  %cpaste

执行剪切板中的程序

```python
%paste会立即获得剪切板中的所有文本并在命令行中作为一个代码块去执行

%cpaste类似，会让你自由粘贴代码，随时可以终止或修改
```



其实这些 **%+"?"**的指令是独属于IPython的特殊命令，被称为“魔术”命令



# 推导式

```python
result = [expr for val in collection if condition]
#也可以是 result = {}    result = ()
#等价于
result = []
for val in collection:
    if condition:
        result.append(val)
```

```Python
#可以嵌套 -->多层循环
```



# lambda

**关键字定义**

```python
key = lambda x: x**2
```







# numpy

## 一、数组创建

#### 直接转换

**np.array( list ) **：直接将数列转换为numpy数组

**np.array( [1, 2, 3] )** :直接创建numpy数组



#### np.ones()

`np.ones(shape, dtype=None, order='C')`：

创建一个填充了具有指定形状的1值的数组。默认的dtype是float64。

```python
ones = np.ones((3,4))
ones ---> array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])
默认dtype('float64')
```



#### np.zeros()

`np.zeros(shape, dtype=None, order='C')`:  

创建一个填充了具有指定形状的0值的数组。默认的dtype是float64。

```python
zeros = np.ones((3,4))
ones ---> array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])
默认dtype('float64')
```



#### np.arange()

`np.arange(start,stop,step,dtype)`:  

创建具有定期递增值的数组。

| 参数    | 描述                 |
| ------- | -------------------- |
| `start` | 起始值,默认为`0`     |
| `stop`  | 终止值（不包含)      |
| `step`  | 两值的间隔,默认为`1` |
| `dtype` | 数据类型             |

```python
arange = np.arange(10,20,2)
arange  --->array([10, 12, 14, 16, 18])

arange = np.arange(10,20,2,dtype=np.float64)
arange  --->array([10., 12., 14., 16., 18.])
```



#### np.linspace()

`np.linspace(start, stop, num, endpoint, retstep, dtype)`:  创建具有指定数量元素的数组，并在指定的开始值和结束值之间平均间隔。

| 参数       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| `start`    | 起始值                                                       |
| `stop`     | 终止值,如果`endpoint`为`True`,包含`stop`值                   |
| `num`      | 生成的等间隔样例数量,默认`50`                                |
| `endpoint` | 是否包含`stop`值,默认`True`                                  |
| `retstep`  | 如果为`True`，返回样例，以及连续数字之间的步长 -------- 返回元组 |
| `dtype`    | 数据类型                                                     |

   ```python
li = np.linspace(2,20,8)
li --->array([ 2. ,  4.57142857,  7.14285714,  9.71428571, 12.28571429,
       14.85714286, 17.42857143, 20. ])

li = np.linspace(2,20,8,retstep=True)
li --->(array([ 2. ,  4.57142857,  7.14285714,  9.71428571, 12.28571429,
        14.85714286, 17.42857143, 20. ]), 2.5714285714285716) # 包含样例
   ```



#### np.logspace

`np.logspace(start, stop, num, endpoint, base, dtype)`:

此函数返回一个`ndarray`对象，其中包含在对数刻度上均匀分布的数字。 刻度的开始和结束端点是某个底数的幂，通常为 10。

| 参数       | 描述                            |
| ---------- | ------------------------------- |
| `start`    | 起始值:`base ** start`          |
| `stop`     | 终止值:`base ** stop`           |
| `num`      | 生成的等间隔样例数量,默认`50`   |
| `endpoint` | 是否包含`stop`值,默认`True`     |
| `base`     | `base`对数空间的底数,默认为`10` |
| `dtype`    | 数据类型                        |

   ```python
# 对数空间为10
log_num = np.logspace(1,2,num=10)
log_num --->array([ 10.        ,  12.91549665,  16.68100537,  21.5443469 ,
        27.82559402,  35.93813664,  46.41588834,  59.94842503,
        77.42636827, 100.        ])
#对数空间为2
log_num = np.logspace(1,2,num=10, base=2)
log_num --->array([2.        , 2.16011948, 2.33305808, 2.5198421 , 2.72158   ,
       2.93946898, 3.1748021 , 3.42897593, 3.70349885, 4.        ])
   ```





**使用特殊库函数（例如，随机random）**

使用`np.random`创建随机数组。

**均匀分布 **

​	`np.random.rand(d0,d1,...,dn)`:根据给定的维度生成**[0, 1)**之间的随机数,**dn**每个维度, 若没有参数，则生成一个数.

```python
np.random.rand() #随机生成一个数
#0.5726008714564191
np.random.rand(2) #随机生成一个一维数组
#array([0.61949677, 0.06182977])
np.random.rand(3,2)
"""array([[0.73937337, 0.34386129],
       [0.89393313, 0.09146219],
       [0.97990048, 0.49450004]])"""
```

​	`np.random.randint(low,high=None,size=None,dtype='l')`:生成取值区间为[low, high)的随机整数，若没有输入参数high则取值区间为[0, low), 

low:最小值,

high:最大值,

size:数组维度大小，dtype:np.int

```python
np.random.randint(3,size=3) #生成3个[0,3)之间的整数
#array([2, 0, 1])
np.random.randint(1,5) #size=None,生成一个[1,5)之间随机的一个整数
# 4
np.random.randint(1,5,size=(3,2)) #生成一个二维数组
"""array([[1, 3],
       [1, 2],
       [2, 4]])"""
```

​	**`np.random.uniform(low=0.0, high=1.0, size=None)`**	:生成取值区间为[low,high)	的浮点数,默认取值范围[0,1.0).

low:最小值,float型,  

high:最大值，float型,

size:数组维度大小，int型或tuple，

没有参数时，则生成一个数。

```python
np.random.uniform() #随机生成一个0-1.0的随机数
#0.1726402474971156
np.random.uniform(size=(3,2)) #随机生成一个数据是0 - 1.0的二维数组
"""array([[0.72540688, 0.47681299],
       [0.90533783, 0.78988655],
       [0.47050509, 0.55306498]])"""
np.random.uniform(-1,1,size=10) #随机生成一个-1 - 1 的10个数的一维数组
"""array([-0.42469769,  0.66898184,  0.12269022,  0.59821852, -0.47739708,
       -0.85804074,  0.2332269 , -0.18532177, -0.04431914,  0.25257431])"""
```

**正态分布**

![正态分布](C:\Users\Without exceotion\Desktop\数据分析\Numpy\正态分布.png)

​	`np.random.randn(d0,d1,....,dn)`:从标准正态分布中返回一个(d0*d1* …* dn)维样本值.**dn**每个维度, 若没有参数，则生成一个数

```python
np.random.randn() #随机生成一个数
#-0.6828353877094375
np.random.randn(1) #随机生成一个一维数组
#array([-0.27862247])
np.random.randn(3,2) #随机二维数组的数组
"""array([[-1.22491603,  1.49204094],
       [-0.17640881, -0.81221251],
       [-0.66017166, -0.18555491]])"""

```

​	**`np.random.normal(loc=0.0, scale=1.0, size=None)`**:  从正态分布中返回样本值. 

 loc：float此概率分布的均值,对应着整个分布的中心centre.

 scale：float此概率分布的标准差,对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高

size：int or tuple 

 输出的shape，默认为None，只输出一个值

```python
np.random.normal()#生成一个随机数，size=None
#-0.11276293905334074
np.random.normal(size=1)#生成一个一维数组
#array([0.20337865])
np.random.normal(1,3,size=(3,2))
"""array([[4.58915271, 3.11798389],
       [3.04339931, 1.13752776],
       [1.64524515, 2.19528162]])
"""
```

​	`np.random.standard_normal(size=None)`:返回一个指定形状的标准正态分布的数组

```python
np.random.standard_normal()#生成一个随机数
#-1.0320902045776343
np.random.standard_normal((3,2))
"""array([[-0.32021508,  1.09101575],
       [ 0.79058298,  1.34311915],
       [ 0.80387764,  1.72679853]])"""
```







## **二、基础**数据结构

1. `Numpy`是`Python`科学计算库,用于快速处理任意维度的数组

2. `NumPy`提供一个**N维数组类型ndarray**，它描述了**相同类型**的“items”的集合。

3. `ndarray`支持向量化运算

   

4. `NumPy`使用c语言写的，底部解除了`GIL`，其对数组的操作速度不在受`python`解释器限制

5. **ndarray**属性

   | 属性             | 描述                     |
   | ---------------- | ------------------------ |
   | ndarray.shape    | 数组维度的元组           |
   | ndarray.ndim     | 数组维数                 |
   | ndarray.size     | 数组中的元素数量         |
   | ndarray.itemsize | 一个数组元素的长度(字节) |
   | ndarray.dtype    | 数组元素的类型           |

6. ```python
   import numpy as np
   
   a = np.array([1,2,3])
   b = np.array([[1,2,3],[4,5,6]])
   c = np.array([[[1,2],[3,4]], [[5,6],[7,8]]])
   #shape表示数组的形状
   #a.shape ---> (3,) 一维数组
   #b.shape --->(2,3)二维数组 2行3列
   #c.shape --->(2,2,2)三维数组
   
   #ndim表示数组的维度
   #a.ndim ---> 1
   #b.ndim ---> 2
   #c.ndim ---> 3
   
   #size表示数组中的元素数量
   #a.size ---> 3
   #b.size ---> 6
   #c.size ---> 8
   
   #dtype表示元组元素的类型
   #a.dtype ---> dtype('int32')
   #b.dtype ---> dtype('int32')
   #c.dtype ---> dtype('int32')
   ```

7. `ndarray`元素数据类型

   `ndarray.dtype`查看数组元素的数据类型,`NumPy`支持比`Python`更多的数值类型

   | 数据类型   | 描述                                                        | 唯一标识符 |
   | ---------- | ----------------------------------------------------------- | ---------- |
   | bool       | 用一个字节存储的布尔类型（True或False）                     | 'b'        |
   | int8       | 一个字节大小，-128 至 127                                   | 'i'        |
   | int16      | 整数，16 位整数(-32768 ~ 32767)                             | 'i2'       |
   | int32      | 整数，32 位整数(-2147483648 ~ 2147483647)                   | 'i4'       |
   | int64      | 整数，64 位整数(-9223372036854775808 ~ 9223372036854775807) | 'i8'       |
   | uint8      | 无符号整数，0 至 255                                        | 'u'        |
   | uint16     | 无符号整数，0 至 65535                                      | 'u2'       |
   | uint32     | 无符号整数，0 至 2 ^ 32 - 1                                 | 'u4'       |
   | uint64     | 无符号整数，0 至 2 ^ 64 - 1                                 | 'u8'       |
   | float16    | 半精度浮点数：16位，正负号1位，指数5位，精度10位            | 'f2'       |
   | float32    | 单精度浮点数：32位，正负号1位，指数8位，精度23位            | 'f4'       |
   | float64    | 双精度浮点数：64位，正负号1位，指数11位，精度52位           | 'f8'       |
   | complex64  | 复数，分别用两个32位浮点数表示实部和虚部                    | 'c8'       |
   | complex128 | 复数，分别用两个64位浮点数表示实部和虚部                    | 'c16'      |
   | object_    | python对象                                                  | 'O'        |
   | string_    | 字符串                                                      | 'S'        |
   | unicode_   | unicode类型                                                 | 'U'        |

   `NumPy`的数值类型实际上是 `dtype `对象的实例，并对应唯一的字符，包括 `np.bool_`，`np.int32`，`np.float32`，等等。

   ```python
   import numpy as np
   d = np.dtype(np.int32)
   print(d) ---> int32
   ```

   ```python 
   # 创建数组指定数据类型
   e = np.array([[1,2],[3,4]],dtype=np.float32)
   e ---> array([[1., 2.],
          [3., 4.]], dtype=float32)
   
   f = np.array([[1,2],[3,4]],dtype=np.dtype('f4'))
   f ---> array([[1., 2.],
          [3., 4.]], dtype=float32)
   
   
   ```

   ```python
   # 创建结构化数据类型
   
   # 1. 创建数据类型
   dt = np.dtype([('price','f4')]) # price 类型的字段名，自定义, 'f4'数据类型 float32
   
   # 2. 将数据类型应用到 ndarray对象
   nd = np.array([(10),(25.8),(36.6)], dtype=dt)
   nd ---> array([(10. ,), (25.8,), (36.6,)], dtype=[('price', '<f4')])
   #创建数组中不同的数据类型数组
   dt = np.dtype([('name','S20'), ('price', 'f4'),
                  ('weight', 'i1')])
   nd = np.array([('meat', 15.6, 2),('apple', 6, 2)],dtype=dt)
   ```









## 三、形状row*column与数据类型的修改

#### np.reshape

`np.reshape(a,newshape,order='C')`:**原数组size不变的前提下**，改变原数组的形状

| 参数     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| ndarray  | 数组                                                         |
| newshape | `int`或`int的tuple` ，新的形状应该和原始形状兼容如果是整数，则结果将是该长度的1-D数组。一个形状维度可以是`-1`。在这种情况下，从数组的长度和其余维度推断该值 |
| order    | {'C', 'F', 'A'} 'C' -- 按行，'F' -- 按列，'A' -- 原顺序。          **默认按行** |



但通常都是直接利用 numpy数组本身的方法 对创建后的数组进行修改的

#### ndarray.reshape

`ndarray.reshape(shape,order='C')`：**原数组size不变的前提下**,返回包含具有新形状的相同数据的数组,与自由函数不同`np.reshape`，此方法`ndarray`允许将shape参数的元素作为单独的参数传递。

```python
#ndarray.reshape方法
#随机生成一个数组
arr1 = np.random.rand(3,4)
""" 
array([[0.40919593, 0.53439411, 0.17478334, 0.88506119],
       [0.52465668, 0.40275561, 0.85389365, 0.69344744],
       [0.06308938, 0.24195379, 0.43457003, 0.5855962 ]])
"""
print(arr2.reshape(2,6)) #默认按行
"""
[[0.40919593 0.53439411 0.17478334 0.88506119 0.52465668 0.40275561]
 [0.85389365 0.69344744 0.06308938 0.24195379 0.43457003 0.5855962 ]]
 """
print(arr2.reshape(6,2,order='F')) #按列
"""
[[0.40919593 0.17478334]
 [0.52465668 0.85389365]
 [0.06308938 0.43457003]
 [0.53439411 0.88506119]
 [0.40275561 0.69344744]
 [0.24195379 0.5855962 ]]
"""

# np.reshape函数
np.reshape(arr2,(-1,3)) # -1从数组的长度和其余维度推断该值
"""
array([[0.40919593, 0.53439411, 0.17478334],
       [0.88506119, 0.52465668, 0.40275561],
       [0.85389365, 0.69344744, 0.06308938],
       [0.24195379, 0.43457003, 0.5855962 ]])
"""
#在转换形状的时候，一定要注意元素的个数，不能发生改变！
```



#### np.resize

`np.resize(ndarray,new_shape)`:改变原数组的形状和大小，与`reshape`不同的是可以改变数组的`size`。如果新数组大于原始数组，则新数组将填充*a的*重复副本。

| 参数      | 描述                |
| --------- | ------------------- |
| ndarray   | 数组                |
| new_shape | `int`或`int的tuple` |



#### ndarray.resize

`ndarray.resize(new_shape)`:就地更改数组的形状和大小，会对原值进行修改并且返回的是`None`

```python
#ndarray.resize
#缩小数组
a = np.array([[0, 1], [2, 3]])
a.resize(2,1)
"""
array([[0],
       [1]])
       """
#扩展数组 缺少的数据用 0 填充
b = np.array([[0, 1], [2, 3]])
b.resize(2,3)
"""
array([[0, 1, 2],
       [3, 0, 0]])
"""

#np.resize
#缩小数组
a=np.array([[0,1],[2,3]])
np.resize(a(1,2))
# array([[0, 1]])  a的值没有变化

#扩展数组 缺少的数据将由填充原数组的重复副本
b=np.array([[0,1],[2,3]])
np.resize(b,(3,3))
"""
array([[0, 1, 2],
       [3, 0, 1],
       [2, 3, 0]])
"""

```



#### ndarray.T

.T:将原shape为（n，m）的数组转置为（m，n），把数组的行和列进行互换，一维数组转置不变。

```python
arr3 = np.arange(12).reshape(3,4)
arr3.T
"""
array([[ 0,  4,  8],
       [ 1,  5,  9],
       [ 2,  6, 10],
       [ 3,  7, 11]])
"""
```



#### ndarray.astype

1. `ndarray.astype(type)`:强制转换为指定的类型。

   ```python
   one = np.ones((3,4))
   one
   """
   array([[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]])
   """
   one.dtype
   #dtype('float64')
   one.astype(np.int64)
   """
   array([[1, 1, 1, 1],
          [1, 1, 1, 1],
          [1, 1, 1, 1]], dtype=int64)
   """
   n1 = np.array(['1','2','3'],dtype=np.string_)
   n1.astype(np.int64)
   #array([1, 2, 3], dtype=int64)
   
   #如果将浮点数转为整数,那么小数部分会被截断
   n2 = np.random.uniform(1,5,size=(3,4))
   n2
   """
   array([[2.54847297, 1.47540363, 3.19716644, 2.88852565],
          [4.35936498, 4.14153717, 4.28468383, 2.98894034],
          [3.34067248, 2.73983194, 4.21287495, 1.30903491]])
   """
   n2.astype(np.int64)
   """
   array([[2, 1, 3, 2],
          [4, 4, 4, 2],
          [3, 2, 4, 1]], dtype=int64)
   """
   ```



## 四、数组切片与索引

`ndarray`对象的内容可以通过`索引`或`切片`来获取和修改，就像 Python 的内置容器对象一样。

#### `一维数组`

一维数组比较简单,看起来和python列表很类似。

```python
a = np.arange(10)
a ---> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

#切片
a[2:5] --->array([2, 3, 4])
a[1::2] --->array([1, 3, 5, 7, 9])  #切片参数(start:stop:step)不包括终止索引
```

```python
#赋值
a[2:5]=88 --->array([ 0,  1, 88, 88, 88,  5,  6,  7,  8,  9])
```

```python
#copy
#浅copy
b = a[2:5]
b[:] = 666
a ---> array([  0,   1, 666, 666, 666,   5,   6,   7,   8,   9])
#深copy
c = a[2:5].copy()
c[:] = 888
a --->array([  0,   1, 666, 666, 666,   5,   6,   7,   8,   9])
```

**深copy新建一个对象重新分配内存地址，复制对象内容。** ---------->新建

**浅copy不重新分配内存地址，内容指向之前的内存地址。**浅copy如果对象中有引用其他的对象，如果对这个子对象进行修改，子对象的内容就会发生更改。 ----------->指针

数组的切片是原数组的视图，数据并不是被复制，任何对于视图的修改都会反映到原数组，想要复制数组的切片必须显示地复制这个数组，使用**copy()**函数



#### `二维数组`

每个索引值对应的元素不在是一个值，而是一个一维数组

```python
arr1 = np.array([[1,2,3],[4,5,6],[7,8,9]])
#索引
arr1[1] --->array([4, 5, 6]) #获取的一个一维数组
arr1[1][1] ---> 5 #通过递归的方式。获取一个值，第一个索引获取到一维数组，第二个索引获取到值
arr1[1, 1] ---> 5 #使用逗号,分割列表去获取单个元素

#切片
arr1[:2] --->array([[1, 2, 3],
       [4, 5, 6]])  # 数组沿着行进行切片
arr1[:2, :2] ---> array([[1, 2],
       [4, 5]]) #多组切片 获取前两行前两列
arr1[:,:1] --->array([[1],[4],[7]]) #选取第一列 ，单独一个: 获取整个轴的数组

#切片和索引混合，可以得到低纬度的切片(数组降维)
arr1[1,:2] --->array([4, 5]) #选取第二行,前两列
arr1[:2,0] --->array([1, 4]) #选取第一列，前两行
```



#### `多维数组`

```python
arr2=np.array([[[1,2,3],[4,5,6]], [[7,8,9],[10,11,12]]])
"""
array([[[ 1,  2,  3],[ 4,  5,  6]],
       [[ 7,  8,  9],[10, 11, 12]],
       [[13, 14, 15],[16, 17, 18]]])
"""
#索引
arr2[0] --->array([[1, 2, 3],[4, 5, 6]]) #获得一个二维数组 获取第1层
arr2[0,0] --->array([1, 2, 3]) #获得一个一维数组 获取第1层的第1行
arr2[0,0,0] ---> 1 #获得一个值

#切片
arr2[:2] ---> array([[[ 1,  2,  3],[ 4,  5,  6]],[[ 7,  8,  9],[10, 11, 12]]]) # 获取前两层
arr2[:2,:1] --->array([[[1, 2, 3]],[[7, 8, 9]]]) # 获取前两层，第一行
arr2[:2,:1,:2] --->array([[[1, 2]],[[7, 8]]]) # 获取前两层的，第一行的前两列

#切片和索引
"""
ndarray[dim1,dim2,...,dim(n-1),dim(n)]
dim(k):----->  l1:l2 :从l1到l2-1
	   ----->  l     :第l+1个
"""
arr2[:,1] --->array([[4, 5, 6],[10, 11, 12],[16, 17, 18]]) #获取所有层的第二行
arr2[:,1,1] --->array([5, 11, 17]) #获取所有层的第2行的第2列
arr2[:2,:2,2] --->array([[3, 6],[9, 12]]) #获取所有层的前2行的第3列
```



#### 布尔索引

**布尔索引**:指的是一个由布尔值组成的数组可以作为一个数组的索引，返回的数据为`True`值对应位置的值。

*布尔值数组长度必须和数组轴索引长度一致*

```python
#一维数组 
arr1 = np.arange(5)
"""[0 1 2 3 4]"""
bool1 = [True,False,False,True,False]
arr1[bool1]
array([0, 3]) #获取到下标0,3位置bool值为True的元素

#二维数组
arr2 = np.random.rand(5,4)
"""
[[0.46997479 0.30359067 0.55125259 0.63899705]
 [0.37201402 0.53077412 0.62129647 0.18914937]
 [0.41954877 0.68191221 0.75394428 0.18423583]
 [0.70372303 0.6412821  0.12537964 0.04018929]
 [0.56545976 0.88056762 0.08840744 0.33807558]]"""
bool1 = [True,False,False,True,False]
arr2[bool1] # 获取数组中下标0,3位置bool值为True的行
"""
[[0.46997479 0.30359067 0.55125259 0.63899705]
 [0.70372303 0.6412821  0.12537964 0.04018929]]
"""

#布尔索引和切片组合
arr2[bool1, 2] 
# array([0.55125259, 0.12537964]) 
arr2[bool1, 1:4] 
"""array([[0.30359067, 0.55125259, 0.63899705],
       [0.6412821 , 0.12537964, 0.04018929]])"""

#布尔赋值
#通过逻辑运算，把满足条件的值设置为指定的值（后面会详细讲到）
bool3 = arr2>0.5
arr2[bool3] = 1
"""
[[0.46997479 0.30359067 1.         1.        ]
 [0.37201402 1.         1.         0.18914937]
 [0.41954877 1.         1.         0.18423583]
 [1.         1.         0.12537964 0.04018929]
 [1.         1.         0.08840744 0.33807558]]
"""
```



#### 花式索引

**花式索引**:指的是用`整数数组`进行数据索引。根据索引数组的值作为目标数组的某个轴的下标来取值。

对于使用一维整型数组作为索引：

*如果目标是一维数组，那么索引的结果就是对应位置的**元素**；*

*如果目标是二维数组，那么索引的结果就是对应下标的**行***

```python
#这里的整数数组可以是Numpy的数组,也可以是Python的列表
arr3=np.random.randint(100,size=(7,5))
arr3
"""
array([[21, 29, 51, 93, 18],
       [16, 79, 63, 55, 40],
       [98, 48, 61, 27, 63],
       [37,  3, 48, 54, 69],
       [92, 78, 92, 93, 17],
       [36, 43, 38, 46, 25],
       [41,  1, 10, 56, 99]])
"""
# 使用花式索引，有顺序
arr3[[0,2,5]] #获取对应下标的行
"""
array([[21, 29, 51, 93, 18],
       [98, 48, 61, 27, 63],
       [36, 43, 38, 46, 25]])
"""
arr3[[-2,-1]] #使用负的索引，从尾部选择
"""
array([[36, 43, 38, 46, 25],
       [41,  1, 10, 56, 99]])
"""

#多个索引数组
arr3[[0,3,5],[2,3,4]] #取出（0,2），（3,3），（5,4）元素
"""
array([51, 54, 25])
"""

#***********************************
arr3[[1,5,6,2]][:,[0,3,1,2]]
# arr3 [[1,5,6,2]]  [[:,[]]]
"""
array([[16, 55, 79, 63],
       [36, 46, 43, 38],
       [41, 56,  1, 10],
       [98, 27, 48, 61]])
"""
#***********************************
```

花式索引和切片不一样，它总是将数据复制到一个新的数组中。！！！





## 五、数组广播

`广播`:广播描述了算法如何在不同形状的数组之间的运算。

#### `Numpy数组算术`

```python
arr1 = np.random.randint(10,size=(3,4))
arr1
"""
array([[2, 1, 0, 0],
       [9, 5, 1, 7],
       [8, 1, 5, 4]])
"""

#最简单的广播，标量和数组组合,标量值2，被广播给乘法运算中的所有其他元素
arr1 * 2  
"""
array([[ 4,  2,  0,  0],
       [18, 10,  2, 14],
       [16,  2, 10,  8]])
"""

#相同尺寸的数组运算
arr1 * arr1 
"""
array([[ 4,  1,  0,  0],
       [81, 25,  1, 49],
       [64,  1, 25, 16]])
"""
#在前面逻辑运算的时候我们已经讲过了，同尺寸的数组可以比较，得到的是一个布尔数组
```



#### `广播的规则`

**对于每个结尾维度(从尾部开始),轴的长度都匹配或者相对应的轴一方长度是1，**

**那么则认为可以兼容广播的，广播会在丢失的或在长度为1的轴上进行**。

```python
arr1 = np.arange(12).reshape(4,3)
arr1
"""
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])
"""

arr2 = np.array([1,2,3])
arr2
"""
array([1, 2, 3])
"""

## arr1的每行都 +arr2
arr3 = arr1 + arr2
arr3
"""
array([[ 1,  3,  5],
       [ 4,  6,  8],
       [ 7,  9, 11],
       [10, 12, 14]])
"""

arr1.shape
(4,3)
arr2.shape
(3,)
#满足我们广播规则,从尾部开始轴的长度匹配,广播是兼容的,广播在丢失的轴上进行。
#案例中丢失的是0轴,按'列'进行广播，一维数组沿0轴进行广播
```

```python
arr4 = np.arange(1,5).reshape(4,1)
arr4
"""
array([[1],
       [2],
       [3],
       [4]])
"""
arr5 = arr1+arr4
arr5
"""
array([[ 1,  2,  3],
       [ 5,  6,  7],
       [ 9, 10, 11],
       [13, 14, 15]])
"""
arr1,shape
(4,3)
arr5.shape
(4,1)
#满足广播规则,从尾部开始，轴的长度一方为1,广播在缺失的轴上进行广播
#案例中丢失的是1轴,按'行'进行广播沿着轴1对二维数组进行广播
```



#### **总结**

1. 操作两个数组，先比较数组的shape：`a.维度相等，b.相对应的轴长度为1`

2. 所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐

3. 输出数组的shape是输入数组shape的各个轴上的最大值







## 六、矩阵乘法

```python
#模拟6位学生成绩（平时成绩0.3和期末成绩0.7）,求总成绩
arr1 = np.random.randint(80,100,size=(6,2))
arr1
"""
array([[88, 91],
       [95, 82],
       [87, 82],
       [97, 97],
       [99, 82],
       [99, 94]])
"""
arr2 =  np.array([0.3,0.7])
arr2
"""
array([0.3, 0.7])
"""
arr1 * arr2 #不符合我们需求
"""
array([[26.4, 63.7],
       [28.5, 57.4],
       [26.1, 57.4],
       [29.1, 67.9],
       [29.7, 57.4],
       [29.7, 65.8]])
"""
arr3 = np.array([[0.3],[0.7]])
"""
array([[0.3],
       [0.7]])
"""
arr1*arr3  #不满足我们数组的广播
```



`矩阵`:**矩阵和array的区别,矩阵必须是二维的,但是array可以是多维**



#### np.mat

`np.mat()`:将数组类型转化为矩阵类型

```python
np.mat(arr1)
"""
matrix([[88, 91],
        [95, 82],
        [87, 82],
        [97, 97],
        [99, 82],
        [99, 94]])
"""
```



#### np.dot

`np.dot()`：矩阵运算

```python
np.dot(arr1,arr3)
"""
array([[90.1],
       [85.9],
       [83.5],
       [97. ],
       [87.1],
       [95.5]])
"""

```



#### `案例`:

```python
"""矩阵A：某公司有四个工厂，分布在不同地区，同时三种产品，产量（单位；t）,矩阵B：第一列表示三种产品的单件利润，第二列表示三种产品的单件体积。求工厂利润和四个工厂产品体积"""
arr1 = np.random.randint(1,5,size=(4,3))
arr1
#四个工厂，三种产品，四行分别代表四个工厂，三列分别代表三种产品的产量
"""
array([[3, 3, 1],
       [4, 2, 4],
       [2, 4, 2],
       [2, 3, 1]])
"""
arr2 = np.random.randint(1,5,size=(3,2))
arr2
"""
array([[4, 3],
       [1, 3],
       [3, 3]])
"""

np.dot(arr1,arr2)
"""
array([[18, 21],
       [30, 30],
       [18, 24],
       [14, 18]])
"""
```









## 七、运算

### 1.数学统计

基础数组统计方法

| 方法   | 描述         |
| ------ | ------------ |
| sum    | 总和         |
| mean   | 平均数       |
| std    | 标准差       |
| var    | 方差         |
| min    | 最小值       |
| max    | 最大值       |
| argmin | 最小值的位置 |
| argmax | 最大值的位置 |

```python
#我们可以调用实例方法,也可以使用顶层的Numpy函数,
arr2 = np.random.randn(4,3)
arr2
"""
array([[ 1.15329974,  2.02817106, -0.12567425],
       [-1.30186382,  0.71690951,  1.42288858],
       [ 0.31400007, -1.16320146,  1.48839135],
       [ 0.34372291, -0.87491238, -1.53228751]])
"""
arr2.sum() #np.sum(arr2)
#2.4694438093171573
arr2.mean()
# 0.20578698410976312
np.argmin(arr2)
# 11
arr2.argmax()
# 1

#指定轴进行运算
#axis:参数用于计算给定轴的统计值,形成一个下降一维度的数组
# axis=1按行 axis=0按列
arr2.max(axis=1)
#array([2.02817106, 1.42288858, 1.48839135, 0.34372291])
arr2.max(axis=0)
#array([1.15329974, 2.02817106, 1.48839135])
np.argmin(arr2,axis=1)
#array([2, 0, 1, 2], dtype=int64)
```



### 2.排序与唯一值

#### arsort()

```python
# 创建一个二维矩阵
matrix = np.array([[4, 2, 1],
                   [2, 3, 9],
                   [8, 1, 6]])

# 获取第一列的排序索引
sort_index = np.argsort(matrix[:, 0])

# 使用排序索引对矩阵进行排序
sorted_matrix = matrix[sort_index]

#排序后
array([[2, 3, 9],
       [4, 2, 1],
       [8, 1, 6]])
```





#### sort()

`sort()`:排序,和python列表类型类似,Numpy数组可以使用`sort`方法排序

```python
#一维数组
arr1 = np.random.randn(6)
arr1
"""
array([[18, 21],
       [30, 30],
       [18, 24],
"""
#sort方法进行排序
arr1.sort()
arr1
"""
array([-1.68364397, -1.17897152, -1.10061833, -0.80371391, -0.23651728,
        0.51205633])
"""

#二维
arr2 = np.random.randn(4,3)
arr2
"""
array([[ 0.25385474,  0.37914431,  0.57455817],
       [ 0.72876383,  0.16524266,  2.00815275],
       [ 1.03371677,  1.650364  ,  0.00470761],
       [-1.42358426,  0.89041625, -2.15399045]])
"""
arr2.sort()#默认按行
"""
array([[ 0.25385474,  0.37914431,  0.57455817],
       [ 0.16524266,  0.72876383,  2.00815275],
       [ 0.00470761,  1.03371677,  1.650364  ],
       [-2.15399045, -1.42358426,  0.89041625]])
"""
arr2.sort(axis=0) #指定0轴 ---> a
arr2
"""
array([[-2.15399045, -1.42358426,  0.57455817],
       [ 0.00470761,  0.37914431,  0.89041625],
       [ 0.16524266,  0.72876383,  1.650364  ],
       [ 0.25385474,  1.03371677,  2.00815275]])
"""
#对于多维数组可以指定axis值，沿着轴对每一个一维数据进行排序
```





#### np.unique()

`np.unique`:返回的是数组中 排序后的 唯一值的 数组

```python
arr3 = np.array([1,2,3,1,2,3])
arr3
# array([1, 2, 3, 1, 2, 3])
arr4 = np.array([[2,3,4],[1,2,3]])
np.unique(arr4)
#array([1, 2, 3, 4])

np.unique(arr3)
#array([1, 2, 3])
```





#### np.in1d()

`np.in1d`:检查一个数组中的值是否在另外一个数组中，并返回一个布尔数组.

```python 
arr3 = np.array([1,2,3,1,2,3])
arr4 = np.array([[2,3,4],[1,2,3]])

np.in1d(arr3,[1,2])
#array([ True,  True, False,  True,  True, False])
np.in1d(arr4,[1,3])
#array([False,  True, False,  True, False,  True])
```







## 八、数组合并/分割/重复

```python
arr1 = np.arange(1,7).reshape(2,3)
arr1
"""
array([[1, 2, 3],
       [4, 5, 6]])
"""
arr2 = np.arange(7,13).reshape(2,3)
arr2
"""
array([[ 7,  8,  9],
       [10, 11, 12]])
"""
```

### 合并

#### np.concatenate

`np.concatenate()`

```python
np.concatenate((arr1,arr2)) #默认axis=0
"""
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])
"""
np.concatenate((arr1,arr2),axis=1) #指定axis=1
"""
array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])
"""
```

#### np.vstack

`np.vstack()`

```python
np.vstack((arr1,arr2)) #沿着轴0合并数组
"""
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])
"""
```

#### np.hstack

`np.hstack()`

```python
np.hstack((arr1,arr2))  #沿着轴1合并数组
"""
array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])
"""
```





### 分割

```python
arr3 = np.random.randn(5,3)
arr3
"""
array([[-1.62753568,  0.09844282,  0.24826172],
       [-0.51082413,  1.02423446, -0.82945161],
       [ 0.68448996,  0.1510686 ,  1.25115637],
       [ 1.68088646,  0.35070315, -0.74911414],
       [ 1.05348859,  1.28620817,  0.1522841 ]])
"""
```

#### np.split

`np.split`

```python
np.split(arr3,[1,3]) #默认按 0轴分割， [1,3]表示数组拆分时，按索引位置拆分
"""
[array([[-1.62753568,  0.09844282,  0.24826172]]),
 array([[-0.51082413,  1.02423446, -0.82945161],
        [ 0.68448996,  0.1510686 ,  1.25115637]]),
 array([[ 1.68088646,  0.35070315, -0.74911414],
        [ 1.05348859,  1.28620817,  0.1522841 ]])]
"""

np.split(arr3,[1,2],axis=1) #指定1轴分割
"""
[array([[-1.62753568],
        [-0.51082413],
        [ 0.68448996],
        [ 1.68088646],
        [ 1.05348859]]), 
 array([[0.09844282],
        [1.02423446],
        [0.1510686 ],
        [0.35070315],
        [1.28620817]]), 
 array([[ 0.24826172],
        [-0.82945161],
        [ 1.25115637],
        [-0.74911414],
        [ 0.1522841 ]])]
"""
np.split(arr3,5) # 5表示把数组分割成5组，只能是均等分割
"""
[array([[-1.62753568,  0.09844282,  0.24826172]]),
 array([[-0.51082413,  1.02423446, -0.82945161]]),
 array([[0.68448996, 0.1510686 , 1.25115637]]),
 array([[ 1.68088646,  0.35070315, -0.74911414]]),
 array([[1.05348859, 1.28620817, 0.1522841 ]])]
"""
#ValueError: array split does not result in an equal division,不是均等分割报这个错
```

#### np.array_split

`np.array_split`:和split的区别是，可以不均等分割

```python
np.array_split(arr3,3) 
"""
[array([[-1.62753568,  0.09844282,  0.24826172],
        [-0.51082413,  1.02423446, -0.82945161]]),
 array([[ 0.68448996,  0.1510686 ,  1.25115637],
        [ 1.68088646,  0.35070315, -0.74911414]]),
 array([[1.05348859, 1.28620817, 0.1522841 ]])]
"""
```

#### np.hsplit

`np.hsplit`:指定1轴分割

```python
np.hsplit(arr3,[1,2])
"""
[array([[-1.62753568],
        [-0.51082413],
        [ 0.68448996],
        [ 1.68088646],
        [ 1.05348859]]), 
 array([[0.09844282],
        [1.02423446],
        [0.1510686 ],
        [0.35070315],
        [1.28620817]]), 
 array([[ 0.24826172],
        [-0.82945161],
        [ 1.25115637],
        [-0.74911414],
        [ 0.1522841 ]])]
 """
```

#### np.vsplit

`np.vsplit`：指定0轴分割

```python 
np.vsplit(arr3,[1,3])
"""
[array([[-1.62753568,  0.09844282,  0.24826172]]),
 array([[-0.51082413,  1.02423446, -0.82945161],
        [ 0.68448996,  0.1510686 ,  1.25115637]]),
 array([[ 1.68088646,  0.35070315, -0.74911414],
        [ 1.05348859,  1.28620817,  0.1522841 ]])]
"""
```



### 重复

#### ndarray.epeat

`repeat`：按照给定的次数，对数组的元素进行复制

```python
arr = np.arange(3)
a = arr.repeat(3) #传入一个整数,元素重复相应的次数
a
#array([0, 0, 0, 1, 1, 1, 2, 2, 2])
b = arr.repeat([2,2,3]) #传入一个整数数组,每个元素会重复相应的不同次数
b
#array([0, 0, 1, 1, 2, 2, 2]) 

#多维
arr = np.random.rand(4,3)
arr
"""
array([[0.43173965, 0.26514662, 0.77984414],
       [0.13906945, 0.25396541, 0.77220584],
       [0.57093281, 0.97762641, 0.68158357],
       [0.7133476 , 0.32654828, 0.02919563]])
"""

arr.repeat(2,axis=0) #指定轴0，也可以指定轴1
"""
array([[0.43173965, 0.26514662, 0.77984414],
       [0.43173965, 0.26514662, 0.77984414],
       [0.13906945, 0.25396541, 0.77220584],
       [0.13906945, 0.25396541, 0.77220584],
       [0.57093281, 0.97762641, 0.68158357],
       [0.57093281, 0.97762641, 0.68158357],
       [0.7133476 , 0.32654828, 0.02919563],
       [0.7133476 , 0.32654828, 0.02919563]])
"""

arr.repeat([1,2,3,4],axis=0) #传入整数数组,整数数组长度要和轴的长度匹配
# axis=0 增行
"""
array([[0.43173965, 0.26514662, 0.77984414],
       [0.13906945, 0.25396541, 0.77220584],
       [0.13906945, 0.25396541, 0.77220584],
       [0.57093281, 0.97762641, 0.68158357],
       [0.57093281, 0.97762641, 0.68158357],
       [0.57093281, 0.97762641, 0.68158357],
       [0.7133476 , 0.32654828, 0.02919563],
       [0.7133476 , 0.32654828, 0.02919563],
       [0.7133476 , 0.32654828, 0.02919563],
       [0.7133476 , 0.32654828, 0.02919563]])
"""

arr.repeat([1,2,3],axis=1)
# axis=1 增列
"""
array([[0.43173965, 0.26514662, 0.26514662, 0.77984414, 0.77984414,0.77984414],
       [0.13906945, 0.25396541, 0.25396541, 0.77220584, 0.77220584,0.77220584],
       [0.57093281, 0.97762641, 0.97762641, 0.68158357, 0.68158357,0.68158357],
       [0.7133476 , 0.32654828, 0.32654828, 0.02919563, 0.02919563,0.02919563]])
"""

```



## 逻辑&where

### 逻辑运算

1. 比较运算符 `>, >=, <, <=, ==, !=` ，比较运算符，返回的是一个布尔数组。

2. 逻辑运算符`与:&, 或:|,非:~`

   ```python
   #比较运算符
   #向量化
   arr1 = np.random.randn(4,3)
   arr1
   """
   array([[-0.11644283,  0.26881624, -0.636891  ],
          [ 0.41491463,  0.75958032, -0.79139132],
          [-0.65056162, -1.65086047,  0.30840633],
          [ 0.44048015,  2.60792486, -1.2136428 ]])
   """
   arr1 < 1
   """
   array([[ True,  True,  True],
          [ True,  True,  True],
          [ True,  True,  True],
          [ True, False,  True]])
   """
   #数组与数组比较
   arr2 = np.random.randn(4,3)
   arr2
   """
   array([[ 1.07975731,  0.48405982,  0.83102948],
          [ 0.25161364, -0.84813959,  0.30692867],
          [ 0.67593645,  2.11885395,  0.52587073],
          [-0.82323498,  0.87254439, -0.55737282]])
   """
   arr1 > arr2
   """
   array([[False, False, False],
          [ True,  True, False],
          [False, False, False],
          [ True,  True, False]])
   """
   ```

   ```python
   #逻辑运算符
   (arr1>-0.5) & (arr1<0.5)
   """
   array([[ True,  True, False],
          [ True, False, False],
          [False, False,  True],
          [ True, False, False]])
   """
   (arr1>-0.5) | (arr1<0.5)
   """
   array([[ True,  True,  True],
          [ True,  True,  True],
          [ True,  True,  True],
          [ True,  True,  True]])
   """
   ~(arr1>0)
   """
   array([[ True, False,  True],
          [False, False,  True],
          [ True,  True, False],
          [False, False,  True]])
   """
   ```

   ```python
   #二元通用函数
   np.logical_and(arr1>-0.5 , arr1<0.5)
   """
   array([[ True,  True, False],
          [ True, False, False],
          [False, False,  True],
          [ True, False, False]])
   """
   np.logical_or(arr1>-0.5 , arr1<0.5)
   """
   array([[ True,  True,  True],
          [ True,  True,  True],
          [ True,  True,  True],
          [ True,  True,  True]])
   """
   np.logical_not(arr1>-0.5)
   """
   array([[False, False,  True],
          [False, False,  True],
          [ True,  True, False],
          [False, False,  True]])
   """
   ```



### np.where

`np.where(condition, x, y)`:是三元表达式 x if condition else y的向量化。如果是True,输出x,相反,False，输出y。传递给np.where的数组可以是同等大小的数组，也可以是标量。

```python
#1.
np.where([[True,False], [True,True]],   #condition
             [[1,2], [3,4]],            #x
             [[9,8], [7,6]])            #y
"""
array([[1, 8],
       [3, 4]])
"""
# 2.
np.where(arr1>0) 
#只有条件 (condition)，没有x和y，则输出满足条件 (即非0) 元素的坐标。这里的坐标以tuple的形式给出，通常原数组有多少维，输出的tuple中就包含几个数组，分别对应符合条件元素的各维坐标。
"""
(array([0, 1, 1, 2, 3, 3], dtype=int64),
 array([1, 0, 1, 2, 0, 1], dtype=int64))
"""
# 3. 典型用法,标量和数组联合，进行值的替换
np.where(arr1>0,1,-1)
"""
array([[-1,  1, -1],
       [ 1,  1, -1],
       [-1, -1,  1],
       [ 1,  1, -1]])
"""
```



### 检查布尔数组

`any(),all()方法`: 这两个方法可以快速检查布尔数组,`any()`:检查数组中是否至少有一个True, `all()`:检查是否每个值都为True.

```python 
(arr1 <1).sum() # True的个数
11

(arr1<1).any()
True

np.all((arr1<1))
False
# 这两个方法同时也可以适用于非布尔数组，非0的 元素就会按True处理
```













# pandas

## Series

### 概述

`Series`:一种一维标记的数组型对象，能够保存任何数据类型，包含了数据标签,称为索引。

### 创建

#### 数组创建

```python
# 通过数组创建
arr1 = np.arange(1,4)
s1 = pd.Series(arr1)
s1
0    1
1    2
2    3
dtype: int32
#索引在左边，值在右边，当我们没有为数据指定索引，默认生成索引
#默认生成的索引是从0到N-1(N是数据的长度)

# values属性和index属性分别获取Series对象的值和索引
s1.values
array([1, 2, 3]) #值就是我们的array对象

s1.index
RangeIndex(start=0, stop=3, step=1) # 和rang(4)类似
```

通常我们都是自己需要创建一个索引序列，用标签标示每个数据点。

```python
#索引长度和数据长度必须相同。
s2 = pd.Series([1,3,-4,8],index=['a','b','c','d'])
s2
a    1
b    3
c   -4
d    8
dtype: int64
  
pd2.index
Index(['a', 'b', 'c', 'd'], dtype='object')
```

#### 字典创建

```python
dict1 = {'name':'hah','age':18,"city":'cs'}
s3 = pd.Series(dict1)
s3
name    hah
age      18
city     cs
dtype: object
#通过字典创建,Series的索引就是我们排序好的字典的键

#也可以按照我们自己想要的顺序去指定索引
s4 = pd.Series(dict1, index=['city','name','age','sex'])
s4
city     cs
name    hah
age      18
sex     NaN
dtype: object
#前三行按照我们给定的顺序生成，但是sex并没有在字典的key中，它对应的值是NaN,
# NaN是pandas中标记的缺失值
```

### 缺失值

**isnull** 和 **notnull** 检查**缺失值** ( NA )

```python
s4.isnull() #判断是否为空,空就是True
city    False
name    False
age     False
sex      True
dtype: bool
    
s4.notnull() # 判断是否不为空,非空就是True
city     True
name     True
age      True
sex     False
dtype: bool

#返回一个Series对象
```

### 索引和切片

```python
s5 = pd.Series(np.random.rand(5),index=['a','b','c','d','e'])
s5
a    0.968340
b    0.727041
c    0.607197
d    0.134053
e    0.240239
dtype: float64
  
# 下标
s5[1] #通过下标获取到元素，不能倒着取，和我们python列表不一样, s5[-1]错误的写法
0.7270408328885498

#通过标签名
s5['c']
0.6071966171492978

#选取多个，还是Series
s5[[1,3]] 或 s5[['b','d']]  # [1,3] 或['b','d']是索引列表
b    0.727041
d    0.134053
dtype: float64

#切片 标签切片包含末端数据（指定了标签）
s5[1:3]
b    0.727041
c    0.607197
dtype: float64
    
s5['b':'d']
b    0.727041
c    0.607197
d    0.134053
dtype: float64
 
#布尔索引
s5[s5>0.5] #保留为True的数据
a    0.968340
b    0.727041
c    0.607197
dtype: float64
```

### name属性

```python
#Series对象本身和其本身索引都具有name属性
s6 = pd.Series({'apple':7.6,'banana':9.6,'watermelon':6.8,'orange':3.6})
s6.name = 'fruit_price'  # 设置Series对象的name属性
s6.index.name = 'fruit'  # 设置索引name属性
s6
fruit
apple         7.6
banana        9.6
watermelon    6.8
orange        3.6
Name: fruit_price, dtype: float64
        
#查看索引
s6.index
Index(['apple', 'banana', 'watermelon', 'orange'], dtype='object', name='fruit')
```





## DataFrame

### 概述

`DateFrame`:一个二维标记数据结构，既有  **行索引**  也有  **列索引**

具有可能不同类型的列，每一列可以是不同值类型(数值，字符串，布尔值)

我们可以把它看作为excel表格，或者SQL表，或Series对象的字典。



从DataFrame中选取的列是数据的**视图**，而不是拷贝，因此对Series等的修改会映射到DataFrame中。如果需要复制则应当使用相关copy方法。



### 构建方法

构建`DateFrame`的方法:

**字典类**：数组、列表或元组构成的字典构造datafram ;

​				Series构成的字典构造dataframe ;

​				字典构成的字典构造dataframe ;

**列表类**：2D ndarray 构造dataframe ;

​				字典构成的列表构造dataframe ;

​				Series构成的列表构造dataframe ;

#### 字典构建

数组、列表或元组构成的字典构造dataframe

```python
#构造一个字典
data = {'a':[1,2,3,4],
        'b':(5,6,7,8),
        'c':np.arange(9,13)}
#构造dataframe
frame = pd.DataFrame(data)
frame
	a	b	c
0	1	5	9
1	2	6	10
2	3	7	11
3	4	8	12	

#index属性查看行索引
frame.index
RangeIndex(start=0, stop=4, step=1)
#columns属性查看列索引
frame.columns
Index(['a', 'b', 'c'], dtype='object')
#values属性查看值
frame.values
array([[ 1,  5,  9],
       [ 2,  6, 10],
       [ 3,  7, 11],
       [ 4,  8, 12]], dtype=int64)
# 每个序列是DateFrame的一列，所有的序列长度必须相等，columns为字典的key,index为默认的数字标签，我们可以通过index属性进行修改

#指定index
frame = pd.DataFrame(data,index=['A','B','C','D'])
frame
	a	b	c
A	1	5	9
B	2	6	10
C	3	7	11
D	4	8	12

#指定columns，显示所指定列的数据，并按指定的顺序进行排序,当没有数据中没有该列('e')，那么就会用NaN来填充
frame = pd.DataFrame(data,index=['A','B','C','D'],columns=['a','b','c','e'])
frame
	a	b	c	e
A	1	5	9	NaN
B	2	6	10	NaN
C	3	7	11	NaN
D	4	8	12	NaN
```

Series构成的字典构造dataframe

```python
pd1 = pd.DataFrame({'a':pd.Series(np.arange(3)),
                   'b':pd.Series(np.arange(3,5)), 
                   })
pd1
	a	b	
0	0	4	
1	1	5	
2	2	NaN	

#设置index,
pd1 = pd.DataFrame({'a':pd.Series(np.arange(3),index=['a','b','c']),
                   'b':pd.Series(np.arange(3,5),index=['a','b']),
                   })
pd1
	a	b
a	0	3.0
b	1	4.0
c	2	NaN
#我们用Series构成的字典创建dataframe，指定索引我们需要在Series里面指定索引,index为Series的标签，Series长度可以不一样，会以NaN填充
```

字典构成的字典构造dataframe

```python
#字典嵌套
data = {
    'a':{'apple':3.6,'banana':5.6},
    'b':{'apple':3,'banana':5},
    'c':{'apple':3.2}
}
#构造dataframe
pd2 = pd.DataFrame(data3)
pd2
		a	b	c
apple	3.6	3	3.2
banana	5.6	5	NaN
#内部字典是一列,内部字典的key是行索引index,外部字典的key是列索引columns,
#可以通过转置.T方法逆转行列索。
```



#### 列表构建

2D ndarray构建

```python
#构造二维数组对象
arr1 = np.arange(12).reshape(4,3)
#构造dateframe
frame1 = pd.DataFrame(arr1)
frame1
	0	1	2
0	0	1	2
1	3	4	5
2	6	7	8
3	9	10	11
#我们通过二维数组对象创建dataframe，行索引和列索引都是可选参数，指定index和columns必须和原数组长度一致，默认0到N-1
frame2 = pd.DataFrame(arr1,index=['a','b','c','d'],columns=['A','B','C'])
frame2
	A	B	C
a	0	1	2
b	3	4	5
c	6	7	8
d	9	10	11
```

字典构成的列表构造dataframe

```python
l1 = [{'apple':3.6,'banana':5.6},{'apple':3,'banana':5},{'apple':3.2}]
pd3 = pd.DataFrame(l1)
pd3
	apple	banana
0	3.6		5.6
1	3.0		5.0
2	3.2		NaN
#列表中的每一个元素是一行,字典的key是列索引columns

#指定行索引index,必须和数据长度一致
pd3 = pd.DataFrame(l1,index=['a','b','c'])
pd3
	apple	banana
a	3.6		5.6
b	3.0		5.0
c	3.2		NaN
```

Series构成的列表构造dataframe

```python
l2 = [pd.Series(np.random.rand(3)),pd.Series(np.random.rand(2))]
pd4=pd.DataFrame(l2)
pd4
	0			1			2
0	0.482106	0.025374	0.020586
1	0.912417	0.229153	NaN
#列表中的每一个元素是一行
#设置行索引index,和原数组长度一致
pd4=pd.DataFrame(l2,index=['a','b'])
pd4
	0			1			2
a	0.482106	0.025374	0.020586
b	0.912417	0.229153	NaN
#设置列索引columns,我们需要在series对象设置index
l2 = [pd.Series(np.random.rand(3),index=['A','B','C']),pd.Series(np.random.rand(2),index=['A','B'])]

pd4=pd.DataFrame(l2,index=['a','b'])
pd4
	  A			  B			 C
a	0.999713	0.507880	0.091274
b	0.798486	0.268391	NaN
```



### 转置

.T

```python
#和Numpy一样，进行转置
pd6 = pd.DataFrame(np.arange(4).reshape(2,2),index=['a','b'],columns=['A','B'])
pd6
	A	B
a	0	1
b	2	3

pd6.T #行和列进行转置
	a	b
A	0	2
B	1	3
```

### 查看数据

查看数据 `head()`，`tail()`

```python
pd5 = pd.DataFrame(np.arange(20).reshape(10,2))
pd5
	0	1
0	0	1
1	2	3
2	4	5
3	6	7
4	8	9
5	10	11
6	12	13
7	14	15
8	16	17
9	18	19

# head()默认查看前5行，输入参数N，就查看前N行
pd5.head()
	0	1
0	0	1
1	2	3
2	4	5
3	6	7
4	8	9

#tail()默认查看后5行,输入参数N，就查看后N行
pd5.tail()
	0	1
5	10	11
6	12	13
7	14	15
8	16	17
9	18	19
```





## 索引增删改查

- reindex重建索引

- drop删除轴上的条目

- 赋值操作

- 索引操作，切片

- loc和iloc的操作（Numpy风格)

  

### 利用reindex创建

`reindex`：该方法用于创建一个符合新索引的新对象

```python
#series
s1 = pd.Series(np.random.rand(4),index=['b','c','a','d'])
s1
b    0.714204
c    0.139476
a    0.362383
d    0.046476
dtype: float64

s2 = s1.reindex(['a','b','c','d','e'])
s2
a    0.362383
b    0.714204
c    0.139476
d    0.046476
e         NaN
dtype: float64
    
# 调用reindex方法,将数据按照新的索引进行排列,如果某个索引值不存在，就会用NaN填充

#dataframe
pd1 = pd.DataFrame(np.arange(9).reshape(3,3),index=['a','c','b'],columns=['A','B','C'])
pd1
	A	B	C
a	0	1	2
c	3	4	5
b	6	7	8
#行重建索引和我们的series一样
pd2 = pd1.reindex(['a','b','c','d'])
pd2
	A	B	C
a	0.0	1.0	2.0
b	6.0	7.0	8.0
c	3.0	4.0	5.0
d	NaN	NaN	NaN
#列重建索引，需要指定参数columns
pd3=pd1.reindex(columns=['C','B','A'])
pd3
	C	B	A
a	2	1	0
c	5	4	3
b	8	7	6
```



### 利用drop删除

`drop`:删除轴上的数据

```python
#series
#删除一条
s1.drop('b')
c    0.139476
a    0.362383
d    0.046476
dtype: float64
#删除多条
s1.drop(['b','c'])
a    0.362383
d    0.046476
dtype: float64

 #dataframe
pd1.drop('a')
	A	B	C
c	3	4	5
b	6	7	8

pd1.drop(['a','c'])
	A	B	C
b	6	7	8

#删除列,删除列需要指定参数axis=1,或者axis='columns'
pd1.drop('A',axis=1)
	B	C
a	1	2
c	4	5
b	7	8

pd1.drop(['A','B'],axis='columns')
	C
a	2
c	5
b	8

#inplace属性，在原对象上进行删除，并不会返回一个新对象
s1.drop('b',inplace=True)
s1
c    0.139476
a    0.362383
d    0.046476
dtype: float64
```



### 赋值

```python
data['D'] =8 #我们选择‘D’列,并且给它赋值为8
data
		A	B	C	D
one		0	1	2	8
two		4	5	6	8
three	8	9	10	8
four	12	13	14	8

#或
data.D = 6
data
		A	B	C	D
one		0	1	2	6
two		4	5	6	6
three	8	9	10	6
four	12	13	14	6

#关于赋值我们有两种操作方法，一种就是直接使用索引，一种可以通过对象.列的形式进行赋值
```



### dataframe索引

```python
#当传递单个元素，或一个列表到 []中如['A']或[['A','B']]，选择列,传递一个切片到[],选择行[:2]或[:'three']
data= pd.DataFrame(np.arange(16).reshape(4,4),index=['one','two','three','four'],columns=['A','B','C','D'])

data
		A	B	C	D
one		0	1	2	3
two		4	5	6	7
three	8	9	10	11
four	12	13	14	15

#直接使用，先列后行
data['A'] #获取到A列，类型是Series
one       0
two       4
three     8
four     12
Name: A, dtype: int32
#选取多列
data[['A','C']]
	A	C
one	0	2
two	4	6
three	8	10
four	12	14

# 选取一个值
data['A']['one']
0

#切片 
data[:2] #获得行
	A	B	C	D
one	0	1	2	3
two	4	5	6	7
```

数据选择

```python
#使用loc和iloc选择数据，Numpy风格获取数据(先行后列)
#loc使用轴标签
#iloc整数标签
data.loc['one','B'] #获取'one'行，'B'列的数据
1

data.loc['one',['B','D']] #获取'one'行，'B','D'列的数据
B    1
D    3
Name: one, dtype: int32

data.iloc[2,[1,3]] #获取第3行，第2,4列的数据
B     9
D    11
Name: three, dtype: int32

#同样也可以用于切片
data.loc[:'three',:'B'] #获取前三行，前两列数据
		A	B
one		0	1
two		4	5
three	8	9

data.iloc[:2,:2] #获取前两行前两列数据
	A	B
one	0	1
two	4	5
#当然也可以切片和索引组合，和我们的Numpy风格一样
```





## 重复索引

我们目前所接触的案例中,我们的索引都是唯一的,但是在`pandas`中，它的索引不一定都是唯一的，在带有重复索引的情况下，在数据选择上有一些差别，根据标签索引会返回一个序列，而不是一个标量值，`is_unique`属性判断索引标签是否唯一,返回一个布尔值

```python
#构建一个具有相同索引的Series
s1 = pd.Series(range(5),index=list('abcda'))
s1
a    0
b    1
c    2
d    3
a    4
dtype: int64
#根据标签索引，返回一个序列
s1['a']  #会取所有轴标签为a的值
a    0
a    4
dtype: int64
    
#构建一个具有相同的行索引和列索引的dataframe
df1 = pd.DataFrame(np.random.rand(4,3),index=list('abca'),columns=list('ABA'))
df1
	A			B			A
a	0.550783	0.855232	0.159598
b	0.497246	0.196161	0.499925
c	0.157437	0.038210	0.808912
a	0.245046	0.212659	0.757890
df1['A']
	A			A
a	0.550783	0.159598
b	0.497246	0.499925
c	0.157437	0.808912
a	0.245046	0.757890

df1.loc['a']
	A			B			A
a	0.550783	0.855232	0.159598
a	0.245046	0.212659	0.757890

#假如数据很多我们怎么判断索引是否重复
df1.index.is_unique
False

df1.columns.is_unique
False
```





## 排序

### sort_index()

`sort_index`：按行或列索引进行排序，按照索引进行排序,注意与reindex()重建索引进行区分

```python
#Series
s1 = pd.Series(np.arange(4),index=list('dbca'))
s1
d    0
b    1
c    2
a    3
dtype: int32

s1.sort_index() #默认升序
a    3
b    1
c    2
d    0
dtype: int32
    
s1.sort_index(ascending=False) #参数ascending=False降序
d    0
c    2
b    1
a    3
dtype: int32

#DataFrmme
pd1=pd.DataFrame(np.arange(12).reshape(4,3),index=list('bdca'),columns=list('BCa'))pd1
	B	C	A
b	0	1	2
d	3	4	5
c	6	7	8
a	9	10	11

#按行排序
pd1.sort_index()
	B	C	A
a	9	10	11
b	0	1	2
c	6	7	8
d	3	4	5

#按列排序，需要知道轴,axis=1或axis='columns'
pd1.sort_index(axis=1)
	A	B	C
b	2	0	1
d	5	3	4
c	8	6	7
a	11	9	10
#同样如果需要指定降序，需要设置参数ascending=False
```



### sort_values()

`sort_values`：按值进行排序

```python
#Series
s2 = pd.Series([5,6,np.nan,1,-1])
s2
0    5.0
1    6.0
2    NaN
3    1.0
4   -1.0
dtype: float64

s2.sort_values() #根据值的大小进行排序,当有缺失值时，会默认排到最后
4   -1.0
3    1.0
0    5.0
1    6.0
2    NaN
dtype: float64

#DataFrame 当我们对dataframe进行值的排序的时候，需要使用参数by
pd2 = pd.DataFrame({'a':[3,7,9,0],'b':[1,-1,4,8],'c':[0,6,-3,2]})
pd2
	a	b	c
0	3	1	0
1	7	-1	6
2	9	4	-3
3	0	8	2

pd2.sort_values(by='b') #指定b列进行排序
	a	b	c
1	7	-1	6
0	3	1	0
2	9	4	-3
3	0	8	2
#也可以进行多列排序,传递一个列名的列表
pd2.sort_values(by=['a','c'])
	a	b	c
3	0	8	2
0	3	1	0
1	7	-1	6
2	9	4	-3
#同样我们也可以根据参数ascending=False来进行降序
pd2.sort_values(by=['a','c'],ascending=False)
	a	b	c
2	9	4	-3
1	7	-1	6
0	3	1	0
3	0	8	2
```





## apply函数

`apply(func,axis)`:将函数`func`应用到一行或一列的一维数组上

```python
#dataframe的apply
#构造一个dataframe
df1 = pd.DataFrame({'Tom':{'English':88,'Math':68},
                  'Joke':{'English':68,'Math':98},
                  'Mabuqi':{'English':58,'Math':48},
                  'Ohio':{'English':48,'Math':78}})

df1
	    Tom	Joke Mabuqi	Ohio
English	88	 68	  58	  48
Math	68	 98	  48	  78
#现在我有两个需求,一个分别求每个学生成绩的平均分,一个是求每科成绩的平均分，想想怎么计算?
#1.求每个学生的平均分
f1 = lambda x: x.mean()
df1.apply(f1)
Tom       78.0
Joke      83.0
Mabuqi    53.0
Ohio      63.0
dtype: float64
#2.求每科的平均分，指定我们的轴axis='columns'或axis=1
df1.apply(f1,axis='columns')
English    65.5
Math       73.0
dtype: float64
#dataframe的apply函数，他接收的参数是一个series对象
    
#Series
s1 = pd.Series(['Tom','Joke','Mabuqi','Ohio'])
s1
0       Tom
1      Joke
2    Mabuqi
3      Ohio
dtype: object
#需求，过滤掉名字长度<3的人
f2 = lambda x: len(x)>3
s1.apply(f2) #这样我们得到一个布尔类型的series
0    False
1     True
2     True
3     True
dtype: bool
    
s1[s1.apply(f)] #这样我们就过滤掉了名字长度小于3的人
1      Joke
2    Mabuqi
3      Ohio
dtype: object 
#series的apply函数，他接收的参数是series里面的各个值
```



## applymap函数

`applymap(func)`将函数应用到`dataframe`每一个元素上

```python
df2 = pd.DataFrame(np.random.rand(4,3))
df2

	0			1			2
0	0.386162	0.178801	0.283059
1	0.386132	0.765665	0.256415
2	0.829829	0.052328	0.344845
3	0.849074	0.949973	0.306215
#需求，这些数据我只要保留两位小数,怎么做？
f3 = lambda x:'%.2f' % x
df2.applymap(f2)
	0		1		2
0	0.39	0.18	0.28
1	0.39	0.77	0.26
2	0.83	0.05	0.34
3	0.85	0.95	0.31
```

1. 总结:

   - DataFrame的`applymap()`和Series的`apply()`方法，都是接收的对象的各个值，进行处理
   - DataFrame的`apply()`接收的是series,DataFrame里面的行或列





## 统计运算

常见统计计算方法表：

|    方法    |         描述         |
| :--------: | :------------------: |
|   count    |     非NA值的个数     |
|  describe  |  各列的汇总统计集合  |
|    sum     |         总和         |
|    mean    |        平均数        |
|    std     |        标准差        |
|    var     |         方差         |
|    min     |        最小值        |
|    max     |        最大值        |
|   idxmin   | 最小值所在的索引标签 |
|   idxmax   | 最大值所在的索引标签 |
|   median   |        中位数        |
| pct_change |        百分比        |

```python
arr1 = np.random.rand(4,3)
pd1 = pd.DataFrame(arr1,columns=list('ABC'),index=list('abcd'))
f = lambda x: '%.2f'% x
pd2 = pd1.applymap(f).astype(float)
pd2
	A		B		C
a	0.87	0.26	0.67
b	0.69	0.89	0.17
c	0.94	0.33	0.04
d	0.35	0.46	0.29

pd2.sum() #默认把这一列的Series计算,所有行求和
A    2.85
B    1.94
C    1.17
dtype: float64
    
pd2.sum(axis='columns') #指定求每一行的所有列的和
a    1.80
b    1.75
c    1.31
d    1.10
dtype: float64
    
pd2.idxmax()#查看每一列所有行的最大值所在的标签索引，同样我们也可以通过axis='columns'求每一行所有列的最大值的标签索引
A    c
B    b
C    a
dtype: object

pd2.describe()#查看汇总
		A			B		C
count	4.000000	4.00000	4.000000
mean	0.712500	0.48500	0.292500
std		0.263613	0.28243	0.271585
min		0.350000	0.26000	0.040000
25%		0.605000	0.31250	0.137500
50%		0.780000	0.39500	0.230000
75%		0.887500	0.56750	0.385000
max		0.940000	0.89000	0.670000

#百分比:除以原来的量
pd2.pct_change() #查看行的百分比变化，同样指定axis='columns'列与列的百分比变化
	A			B			C
a	NaN			NaN			NaN
b	-0.206897	2.423077	-0.746269
c	0.362319	-0.629213	-0.764706
d	-0.627660	0.393939	6.250000
```



## 算术运算和数据对齐

1. 在我们`pandas`中有一个很重要的特性，不同的索引对象之间可以进行算术运算(加，减，乘，除...)

   ```python 
   #我们可以先看案例,不同的索引对象相加
   
   #Series
   s1 = pd.Series(np.random.rand(4),index=['a','b','c','d'])*100
   s2 = pd.Series(np.random.rand(4),index=['a','d','e','f'])*100
   
   s1
   a    72.868475
   b    86.868903
   c    74.800287
   d    59.727382
   dtype: float64
   
   s2
   a    90.683489
   d    34.670433
   e    12.572728
   f    82.626782
   dtype: float64
   #将s1和s2对象相加
   s1 + s2
   a    163.551964
   b           NaN
   c           NaN
   d     94.397815
   e           NaN
   f           NaN
   dtype: float64
   """
   我们不同的Series对象进行算术运算,在没有相同的标签位置上,内部数据对齐就会产生缺失值,具有相同的标签的值,会进行算术运算,索引对不相同,返回的结果的索引就是索引对的并集,Series进行算术运算的时候,不需要保证Series大小的一致
   """
   
   #DataFrame
   df1 = pd.DataFrame(np.random.rand(12).reshape(4,3)*100, index=['a','b','c','d'],columns=list('ABC'))
   
   df2 = pd.DataFrame(np.random.rand(9).reshape(3,3)*100, index=['a','d','f'],columns=list('ABD'))
   
   df1
   	A			B			C
   a	26.869112	70.599906	32.586599
   b	46.996796	19.524614	74.472748
   c	94.605620	94.174812	29.406223
   d	93.409041	56.094164	21.006926
   
   df2
   		A		B			D
   a	81.508766	61.112238	94.539634
   d	7.888379	90.192787	3.874301
   f	8.415423	52.471031	43.082653
   
   df1+df2
   	A			B			C	   D
   a	108.377878	131.712144	 NaN	NaN
   b	NaN			NaN			NaN	   NaN
   c	NaN			NaN			NaN	   NaN
   d	101.297420	146.286951	 NaN	NaN
   f	NaN			NaN			NaN	   NaN
   """
   将两个不同的DataFrame进行算术，返回一个DataFrame，它的行索引和列索引，是每个DataFrame的索引,列的并集,在没有相同的标签位置上,内部数据对齐就会产生缺失值,具有相同的标签的值,会进行算术运算,
   """
   ```

2. 使用填充值的`算术方法`:

   如上面的案例一样，两个不同的索引对象之间进行算术操作时，当一个标签存在一个对象上，在另外的一个对象中不存在，会出现缺失值，我们可以通过下表中的`算术方法`将缺失值进行填充。

   **算术方法表**:

   |        方法         |     描述     |
   | :-----------------: | :----------: |
   |      add，sadd      |  加法（+）   |
   |      sub，rsub      |  减法（-）   |
   |      div，rdiv      |  除法（/）   |
   | floordiv，rfllordiv |  整除（//）  |
   |      mul，rmul      |  乘法（*）   |
   |      pow，rpow      | 幂次方（**） |

   ```python
   #我们对上面的案例使用算术方法实现
   s1.add(s2) 
   a    163.551964
   b           NaN
   c           NaN
   d     94.397815
   e           NaN
   f           NaN
   dtype: float64
   #效果和我们的s1 + s2等同，算术方法中有个参数,fill_value参数，可以对缺失值进行填充
   s1.add(s2,fill_value=0)
   a    163.551964
   b     86.868903
   c     74.800287
   d     94.397815
   e     12.572728
   f     82.626782
   dtype: float64
   
       
   df1.add(df2)
   	A			B			C	   D
   a	108.377878	131.712144	 NaN	NaN
   b	NaN			NaN			NaN	   NaN
   c	NaN			NaN			NaN	   NaN
   d	101.297420	146.286951	 NaN	NaN
   f	NaN			NaN			NaN	   NaN
       
   df1.add(df2,fill_value=0)
   	A			B			C			D
   a	108.377878	131.712144	32.586599	94.539634
   b	46.996796	19.524614	74.472748	NaN
   c	94.605620	94.174812	29.406223	NaN
   d	101.297420	146.286951	21.006926	3.874301
   f	8.415423	52.471031	NaN			43.082653
   
   #使用fill_value指定填充值，未对齐的数据将和填充值进行运算
   #可以理解为不存在的索引，用指定的值（存在的索引的值）进行填充
   
   
   
   #在上表中,每个方法都有个以 r 开头的方法, r开头的方法参数是可以翻转的
   100 / df1 #100除以df1
   		A		B			C
   a	3.721746	1.416432	3.068746
   b	2.127805	5.121740	1.342773
   c	1.057020	1.061855	3.400641
   d	1.070560	1.782717	4.760335
   
   df1.rdiv(100) #同样也是100除以df1
   		A		B			C
   a	3.721746	1.416432	3.068746
   b	2.127805	5.121740	1.342773
   c	1.057020	1.061855	3.400641
   d	1.070560	1.782717	4.760335
   #这两种方法是等价的
   
   
   
   #对于我们的索引重建，如果某个索引值不存在会以NaN进行填充,我们也可以通过fill_value参数进行填充,填充的值由我们自己指定
   df1.reindex(columns=list('ABCE'),fill_value=0)
   	A			B			C		  E
   a	26.869112	70.599906	32.586599	0
   b	46.996796	19.524614	74.472748	0
   c	94.605620	94.174812	29.406223	0
   d	93.409041	56.094164	21.006926	0
   ```

3. DataFrame和Series混合运算

   ```python
   #DataFrame和Series的算术运算和我们的Numpy不同维度的运算操作类似
   #DataFrame与Series的数学操作会把Series的索引和DataFrame的列进行匹配，然后广播到行,大家可以参考我们Numpy的二维数组和一维数组的广播
   df1 #还是我们上面的df1
   	A			B			C
   a	26.869112	70.599906	32.586599
   b	46.996796	19.524614	74.472748
   c	94.605620	94.174812	29.406223
   d	93.409041	56.094164	21.006926
   
   s3 = df1.loc['a'] #获取df1的a行，是个series
   s4 = df1.A
   #dataframe 和series进行运算
   df1 + s3
   	A			B			C
   a	53.738224	141.199812	65.173199
   b	73.865908	90.124520	107.059347
   c	121.474731	164.774718	61.992822
   d	120.278153	126.694070	53.593525
   
   df1 + s4
   	A	B	C	a	b	c	d
   a	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   b	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   c	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   d	NaN	NaN	NaN	NaN	NaN	NaN	NaN
   #可以明显看出Series的索引和DataFrame的列进行匹配,广播到各行
   
   
   #那么如果我们要在行上匹配，广播到行，
   # 1. 使用我们的算术方法,必须指定axis=0或axis='index'，传递的axis值是用于匹配轴的
   S4
   a    26.869112
   b    46.996796
   c    94.605620
   d    93.409041
   Name: A, dtype: float64
   
   df1.add(s4,axis='index')
   	A			B			C
   a	53.738224	97.469018	59.455711
   b	93.993592	66.521410	121.469543
   c	189.211239	188.780432	124.011843
   d	186.818082	149.503204	114.415967
   
   # 2. 我们可以将DataFrame进行转置,进行运算，然后在转置回到原来的数据结构
   df1.T
   	a			b			c			d
   A	26.869112	46.996796	94.605620	93.409041
   B	70.599906	19.524614	94.174812	56.094164
   C	32.586599	74.472748	29.406223	21.006926
   
   (df.T+s4).T
   	A			B			C
   a	53.738224	97.469018	59.455711
   b	93.993592	66.521410	121.469543
   c	189.211239	188.780432	124.011843
   d	186.818082	149.503204	114.415967
   #这两种方法都行，第二种转置的方法可能比较绕，推荐使用算术方法，指定轴进行匹配
   ```













# matplotlib

```python
# 导入绘图包
from matplotlib import pyplot as plt

import matplotlib.pyplot as plt
```



## 常用图表

### 折线图

**折线图**：*可以很直观的反应出数据的变化趋势，反应事物的变化情况*

- *应用场景：适合二维的大数据集，还适合多个二维数据集的比较*

**案例**

- *绘制标普500指数的收盘价的变化*

  ```python
  import numpy as np
  import pandas as pd
  import matplotlib.pyplot as plt
  
  data = pd.read_csv('d:/test_data/spx.csv',index_col='Unnamed: 0',parse_dates=True) #index_col:DataFrame的列用作行索引， parse_dates:解析索引
  
  data.head()
  			SPX
  1990-02-01	328.79
  1990-02-02	330.92
  1990-02-05	331.85
  1990-02-06	329.66
  1990-02-07	333.75
  ```

  **面向对象画图**

  ```python
  #创建画布
  fig,ax=plt.subplots(figsize=(16,6),dpi=100)
  #准备数据
  x=data.index
  y=data['SPX']
  ax.plot(x,y,color='r')
  plt.show()
  ```

  ![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\案例1-1.png)

  *在图中截取2007-2010年金融危机部分*

  ```python
  #截取2007-2011年
  #set_xlim, setylim：设置图表的边界
  
  ax.set_xlim(['2007-1-1','2011-1-1'])
  
  #截取SPX>600
  ax.set_ylim([600,1800])
  
  #添加标题
  ax.set_title('2007-2010年金融危机标普500指数变化趋势')
  
  #添加坐标轴标签
  ax.set_xlabel('Date')
  ax.set_ylabel('SPX')
  ```

  ![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\案例1-2.png)

  *在图中添加文字*

  ```python
  # ax.annotate('Peak of bull market',xy=(datetime(2007,10,11),y['2007-10-11']),
             xytext=(datetime(2007,10,11),y['2007-10-11'] + 160),
             arrowprops=dict(facecolor='c'))
  """
  s:字符串，注释文本
  xy：注释的点(x,y)
  xytext:放置文本的位置(x,y)
  arrowprops:在xy和xytext之间绘制箭头的属性(字典)
  """
  
  crisis_date = [
      (datetime(2007,10,11),'Peak of bull market'),
      (datetime(2008,3,12),'Bear Stearns Fails'),
      (datetime(2008,9,15),'Lehman Bankruptcy')
  ]
  
  for date,label in crisis_date:
      ax.annotate(label,xy=(date,y[date]),
                  xytext=(date,y[date]+160),
                  arrowprops=dict(facecolor='c'))
  ```

  ![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\案例1-3.png)

  *关于annotate更多请参考：*

  *https://matplotlib.org/api/_as_gen/matplotlib.pyplot.annotate.html*

  *https://matplotlib.org/users/annotations_intro.html*

  *在这里我们另外补充了面向对象画图的另外几个功能*

- **Dataframe画图**

  *在前面我们都是直接使用 matplotlib进行绘图，我们的pandas集成了matplotlib画图的方法，我们也可以还有 pandas直接进行绘制*

  ```python
  import numpy as np
  import pandas as pd
  import matplotlib.pyplot as plt
  from datetime import datetime
  
  data = pd.read_csv('d:/test_data/spx.csv',index_col='Unnamed: 0',parse_dates=True)
  
  data.plot(figsize=(16,6),color='r',
            xlim=['2007-1-1','2011-1-1'],
            ylim =[600,1800],
           title='2007-2010年金融危机标普500指数变化趋势'
           )
  #plt.xlim(['2007-1-1','2011-1-1'])
  #plt.ylim([600,1800])
  plt.xlabel('Date')
  plt.ylabel('SPX')
  
  crisis_date = [
      (datetime(2007,10,11),'Peak of bull market'),
      (datetime(2008,3,12),'Bear Stearns Fails'),
      (datetime(2008,9,15),'Lehman Bankruptcy')
  ]
  for date,label in crisis_date:
      plt.annotate(label,xy=(date,y[date]),
                   xytext=(date,y[date]+160),
                   arrowprops=dict(facecolor='c'))
  plt.show()
  ```

  ![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\dateframe1.png)

- *我们使用dataframe画图，当不能满足于我们的需求时，可以和 plt方法，或者面向画图方法结合使用*







### 散点图

**散点图**：*用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联或总结坐标点的分布模式。散点图将序列显示为一组点。值由点在图表中的位置表示。*

*应用场景：判断两个变量之间是否存在关联，判断异常值*

*探究 投资额和住宅投资的关系*

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

data = pd.read_csv('d:/test_data/房地产投资金额.csv',engine='python',index_col=0)

data.plot(kind='scatter',x='投资额',y='住宅',figsize=(16,9),color='r')
#dataframe绘制散点图,需要指定x,y为 dataframe中的列,同样可以给图像添加样式,如指定color,alpha,marker
plt.show()

#从图中我们可以看出,投资额和住宅成正比关系
```

![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\散点图.png)







### 柱状图

**柱状图**：*一种以长方形的长度为变量的表达图形的统计报告图，由一系列高度不等的纵向条纹表示数据分布的情况，用来比较两个或以上的价值（不同时间或者不同条件），只有一个变量，通常利用于较小的数据集分析*

- 柱状图：*柱形图、堆积柱形图、百分比堆积柱形图等。*
- *适用场景*
  1. 适合分析分类数据字段、或者连续的数据字段，利用柱子的高度来反映数据的数值差异。、
  2. 适合分析对比组内各项数据
  3. 堆积柱：可以形象的展示一个大分类包含的每个小分类的数据，以及小分类的占比情况，显示的是单个项目与整体之间的关系
  4. 百分比堆积柱形图：矩形高度表示每子项占当前项的百分比

**案例**

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

data = pd.read_csv('d:/test_data/房地产投资金额.csv',index_col='地区',engine='python')
data1 = data[0:5]
data1.plot.bar(figsize=(16,9))
#data1.plot(kind=bar,figsize=(16,9))
plt.show()

#在柱状图中，每一行的值进行分组，我们可以看出北京是一组，天津是一组，河北是一组
```

![柱状图1](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\柱状图1.png)

#### 条形图

维度分类较多或维度名称比较长的时候使用横向树状图（条形图）

```python
data.plot(kind='barh',figsize(16,9))
plt.show()
```

![条形图](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\条形图.png)

#### 堆积图

*更直观对比整体的数据，可以更清晰的看出各种类别的占比情况*

```python
data.plot(kind='barh',stacked=True,figsize=(16,9)) #传递参数stacked=True来生成堆积树状图
plt.show()
```

![堆积图](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\堆积图.png)

#### 百分比堆积树状图

*展示的占比的情况*

```python
data.div(data.sum(1),axis=0).plot(kind='barh',figsize=(16,9),stacked=True)
plt.show()
```

- ![百分比](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\百分比.png)







### 直方图

**直方图**：*又称质量分布图，是一种统计报告图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据类型，纵轴表示分布情况。用来整理计量值的观测数据，分析其分布状态的统计方法，用于对总体的分布特征进行推断*

*应用场景：表示分布状态，分析数据是否服从正态分布，判断数据是否异常或者孤立*

*直方图与柱状图的比较：*

- **直方图展示数据的分布，柱状图比较数据的大小**。这是直方图与柱状图**最根本的区别**。直方图表示在一定值的区间中，有多少数据，表现的是数据的分布情况。柱状图表示，每一个数据的值的大小，表现的是值大小的对比

- **直方图X轴为定量数据，柱状图X轴为分类数据。** 直方图的x轴通常是连续排列的，柱状图是分开排列的

  ![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\直方图与柱状图比较.png)

- 柱状图是以矩形的长度表示每一组的数据大小，其宽度(表示类别)则是固定的，**利于较小的数据集分析**。

- 直方图是以矩形的长度表示每一组的频数或频率，宽度则表示各组的组距，因此其高度与宽度均有意义，利于**展示大量数据集的统计结果**。

*画直方图一般流程*

- 计算极差（最大值 - 最小值）
- 设置组距
- 计算组数（极差/ 组距）(通常对于数据较少的情况，分为5 ~ 12组 )

**案例**

```python
#绘制分布直方图

#在这里我们直接分组设置成了25组
data.plot(kind='hist',bins=25,figsize=(16,9),subplots=True) #subplots:将Dataframe的每一列绘制在子图中

#data.plot(kind='hist',bins=25,figsize=(16,9),subplots=True,density=True) # density绘制直方频率图，面积总和为1
plt.show()
```

![直方图](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\直方图.png)





### 密度图

**密度图**：*用于显示数据在连续区间内的分布状况。这种图表是直方图的变种，使用平滑曲线来绘制数值水平，从而得出更平滑的分布。密度图的峰值显示数值在该时间段内最为高度集中的位置。*

- *密度图其中一个比直方图优胜的地方，是由于它们不受所使用分组数量（典型直方图中所使用的条形）的影响，所以能更好地界定分布形状 。*

  ```python
  #绘制密度曲线图
  data.plot(kind='kde',figsize=(16,9)) 
  ```

  ![密度曲线图](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\密度曲线图.png)







### 饼图

**饼图**：*用于表示不同分类的占比情况，通过弧度大小来对比各种分类。饼图通过将一个圆饼按照分类的占比划分成多个区块，整个圆饼代表数据的总量，每个区块（圆弧）表示该分类占总体的比例大小，所有区块（圆弧）的加和等于 100%。*

*应用场景：分类占比*

*每个省份投资额占比*

```python
#由于分类过多，截取前5组数据进行绘图

# y 为dataframe列名，或者列名列表,当绘制多列数据,指定subplots=True，绘制在不同的子图中
# autopct:在图中显示百分比
#shadow:布尔值,为饼图增加阴影效果
# explode:为饼图增加破裂效果，值越大，破裂越大
#startangle:饼图旋转角度，从X轴逆时针旋转
data[0:5].plot(kind='pie',y='投资额',figsize=(16,9),autopct="%1.2f%%",shadow=True,explode=(0,0,0.3,0,0),startangle=90)

#让饼图保持正圆形
plt.axis('equal')
plt.show()
```

![](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\饼图.png)





### 箱线图

**箱线图**：*是一种直观简洁的方式去呈现一组数据的分布. 因其形状如箱子而得名. 箱线图广泛用于各个数据分析领域.  它能非常简单明了地显示一组数据中5个重要数值, 最大值 (Maximum Value), 最小值 (Minimum Value), 中位数 (Median Value), 下四分位数 (First Quartile), 上四分位数 (Third Quartile). 箱线图还能发现一组数据中的存在的异常值 (Outliers).*

*分位数*：*把所有数值由小到大排列并分成四等份，处于三个分割点位置的数值就是四分位数。*

![箱线图6](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\箱线图6.jpg)

*查看投资数据的异常值*

```python
data.plot(kind='box',figsize=(16,9))
plt.show()

#高于上边缘的值，为异常值,我们可以用于查看异常值
```

![箱线图](C:\Users\Without exceotion\Desktop\数据分析\matplotlib\图\箱线图.png)





















































